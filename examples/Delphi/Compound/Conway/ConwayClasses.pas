(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2002-04-05 16:57:27         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit ConwayClasses;

{$DEFINE ConwayClasses_unitheader}
{$INCLUDE ConwayClasses_Interface.inc}

uses
  // implementation uses
  BoldReferenceHandle,
  BoldCheckBox,
  Dialogs,
  Forms,
  BoldQueue,
  // implementation dependencies
  // other
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }

{$INCLUDE ConwayClasses.inc}

const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{ TCell }

function TCell._Get_M_Active: TBABoolean;
begin
  assert(ValidateMember('TCell', 'Active', 0, TBABoolean));
  Result := TBABoolean(BoldMembers[0]);
end;

function TCell._GetActive: Boolean;
begin
  Result := M_Active.AsBoolean;
end;

procedure TCell._SetActive(NewValue: Boolean);
begin
  M_Active.AsBoolean := NewValue;
end;

function TCell._Get_M_neighbours: TBAInteger;
begin
  assert(ValidateMember('TCell', 'neighbours', 1, TBAInteger));
  Result := TBAInteger(BoldMembers[1]);
end;

function TCell._Getneighbours: Integer;
begin
  Result := M_neighbours.AsInteger;
end;

function TCell._Get_M_x: TBAInteger;
begin
  assert(ValidateMember('TCell', 'x', 2, TBAInteger));
  Result := TBAInteger(BoldMembers[2]);
end;

function TCell._Getx: Integer;
begin
  Result := M_x.AsInteger;
end;

procedure TCell._Setx(NewValue: Integer);
begin
  M_x.AsInteger := NewValue;
end;

function TCell._Get_M_y: TBAInteger;
begin
  assert(ValidateMember('TCell', 'y', 3, TBAInteger));
  Result := TBAInteger(BoldMembers[3]);
end;

function TCell._Gety: Integer;
begin
  Result := M_y.AsInteger;
end;

procedure TCell._Sety(NewValue: Integer);
begin
  M_y.AsInteger := NewValue;
end;

function TCell._Get_M_ActiveCount: TBAInteger;
begin
  assert(ValidateMember('TCell', 'ActiveCount', 4, TBAInteger));
  Result := TBAInteger(BoldMembers[4]);
end;

function TCell._GetActiveCount: Integer;
begin
  Result := M_ActiveCount.AsInteger;
end;

function TCell._Get_M_Game: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'Game', 5, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[5]);
end;

function TCell._GetGame: TGame;
begin
  assert(not assigned(M_Game.BoldObject) or (M_Game.BoldObject is TGame), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Game', M_Game.BoldObject.ClassName, 'TGame']));
  Result := TGame(M_Game.BoldObject);
end;

procedure TCell._SetGame(value: TGame);
begin
  M_Game.BoldObject := value;
end;

function TCell._Get_M_cLeft: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cLeft', 6, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[6]);
end;

function TCell._GetcLeft: TCell;
begin
  assert(not assigned(M_cLeft.BoldObject) or (M_cLeft.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cLeft', M_cLeft.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cLeft.BoldObject);
end;

procedure TCell._SetcLeft(value: TCell);
begin
  M_cLeft.BoldObject := value;
end;

function TCell._Get_M_cRight: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cRight', 7, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[7]);
end;

function TCell._GetcRight: TCell;
begin
  assert(not assigned(M_cRight.BoldObject) or (M_cRight.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cRight', M_cRight.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cRight.BoldObject);
end;

procedure TCell._SetcRight(value: TCell);
begin
  M_cRight.BoldObject := value;
end;

function TCell._Get_M_cDown: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cDown', 8, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[8]);
end;

function TCell._GetcDown: TCell;
begin
  assert(not assigned(M_cDown.BoldObject) or (M_cDown.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cDown', M_cDown.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cDown.BoldObject);
end;

procedure TCell._SetcDown(value: TCell);
begin
  M_cDown.BoldObject := value;
end;

function TCell._Get_M_cUp: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cUp', 9, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[9]);
end;

function TCell._GetcUp: TCell;
begin
  assert(not assigned(M_cUp.BoldObject) or (M_cUp.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cUp', M_cUp.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cUp.BoldObject);
end;

procedure TCell._SetcUp(value: TCell);
begin
  M_cUp.BoldObject := value;
end;

function TCell._Get_M_cDownLeft: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cDownLeft', 10, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[10]);
end;

function TCell._GetcDownLeft: TCell;
begin
  assert(not assigned(M_cDownLeft.BoldObject) or (M_cDownLeft.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cDownLeft', M_cDownLeft.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cDownLeft.BoldObject);
end;

procedure TCell._SetcDownLeft(value: TCell);
begin
  M_cDownLeft.BoldObject := value;
end;

function TCell._Get_M_cUpRight: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cUpRight', 11, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[11]);
end;

function TCell._GetcUpRight: TCell;
begin
  assert(not assigned(M_cUpRight.BoldObject) or (M_cUpRight.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cUpRight', M_cUpRight.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cUpRight.BoldObject);
end;

procedure TCell._SetcUpRight(value: TCell);
begin
  M_cUpRight.BoldObject := value;
end;

function TCell._Get_M_cDownRight: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cDownRight', 12, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[12]);
end;

function TCell._GetcDownRight: TCell;
begin
  assert(not assigned(M_cDownRight.BoldObject) or (M_cDownRight.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cDownRight', M_cDownRight.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cDownRight.BoldObject);
end;

procedure TCell._SetcDownRight(value: TCell);
begin
  M_cDownRight.BoldObject := value;
end;

function TCell._Get_M_cUpLeft: TBoldObjectReference;
begin
  assert(ValidateMember('TCell', 'cUpLeft', 13, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[13]);
end;

function TCell._GetcUpLeft: TCell;
begin
  assert(not assigned(M_cUpLeft.BoldObject) or (M_cUpLeft.BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'cUpLeft', M_cUpLeft.BoldObject.ClassName, 'TCell']));
  Result := TCell(M_cUpLeft.BoldObject);
end;

procedure TCell._SetcUpLeft(value: TCell);
begin
  M_cUpLeft.BoldObject := value;
end;

procedure TCellList.Add(NewObject: TCell);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TCellList.IndexOf(anObject: TCell): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TCellList.Includes(anObject: TCell) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TCellList.AddNew: TCell;
begin
  result := TCell(InternalAddNew);
end;

procedure TCellList.Insert(index: Integer; NewObject: TCell);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TCellList.GetBoldObject(index: Integer): TCell;
begin
  result := TCell(GetElement(index));
end;

procedure TCellList.SetBoldObject(index: Integer; NewObject: TCell);
begin;
  SetElement(index, NewObject);
end;

{ TGame }

function TGame._Get_M_TimerTime: TBAInteger;
begin
  assert(ValidateMember('TGame', 'TimerTime', 0, TBAInteger));
  Result := TBAInteger(BoldMembers[0]);
end;

function TGame._GetTimerTime: Integer;
begin
  Result := M_TimerTime.AsInteger;
end;

procedure TGame._SetTimerTime(NewValue: Integer);
begin
  M_TimerTime.AsInteger := NewValue;
end;

function TGame._Get_M_Generations: TBAInteger;
begin
  assert(ValidateMember('TGame', 'Generations', 1, TBAInteger));
  Result := TBAInteger(BoldMembers[1]);
end;

function TGame._GetGenerations: Integer;
begin
  Result := M_Generations.AsInteger;
end;

procedure TGame._SetGenerations(NewValue: Integer);
begin
  M_Generations.AsInteger := NewValue;
end;

function TGame._Get_M_board: TBABlob;
begin
  assert(ValidateMember('TGame', 'board', 2, TBABlob));
  Result := TBABlob(BoldMembers[2]);
end;

function TGame._Getboard: String;
begin
  Result := M_board.AsString;
end;

procedure TGame._Setboard(NewValue: String);
begin
  M_board.AsString := NewValue;
end;

function TGame._Get_M_xMax: TBAInteger;
begin
  assert(ValidateMember('TGame', 'xMax', 3, TBAInteger));
  Result := TBAInteger(BoldMembers[3]);
end;

function TGame._GetxMax: Integer;
begin
  Result := M_xMax.AsInteger;
end;

procedure TGame._SetxMax(NewValue: Integer);
begin
  M_xMax.AsInteger := NewValue;
end;

function TGame._Get_M_xMin: TBAInteger;
begin
  assert(ValidateMember('TGame', 'xMin', 4, TBAInteger));
  Result := TBAInteger(BoldMembers[4]);
end;

function TGame._GetxMin: Integer;
begin
  Result := M_xMin.AsInteger;
end;

procedure TGame._SetxMin(NewValue: Integer);
begin
  M_xMin.AsInteger := NewValue;
end;

function TGame._Get_M_yMax: TBAInteger;
begin
  assert(ValidateMember('TGame', 'yMax', 5, TBAInteger));
  Result := TBAInteger(BoldMembers[5]);
end;

function TGame._GetyMax: Integer;
begin
  Result := M_yMax.AsInteger;
end;

procedure TGame._SetyMax(NewValue: Integer);
begin
  M_yMax.AsInteger := NewValue;
end;

function TGame._Get_M_yMin: TBAInteger;
begin
  assert(ValidateMember('TGame', 'yMin', 6, TBAInteger));
  Result := TBAInteger(BoldMembers[6]);
end;

function TGame._GetyMin: Integer;
begin
  Result := M_yMin.AsInteger;
end;

procedure TGame._SetyMin(NewValue: Integer);
begin
  M_yMin.AsInteger := NewValue;
end;

function TGame._Get_M_xSize: TBAInteger;
begin
  assert(ValidateMember('TGame', 'xSize', 7, TBAInteger));
  Result := TBAInteger(BoldMembers[7]);
end;

function TGame._GetxSize: Integer;
begin
  Result := M_xSize.AsInteger;
end;

function TGame._Get_M_FontSize: TBAInteger;
begin
  assert(ValidateMember('TGame', 'FontSize', 8, TBAInteger));
  Result := TBAInteger(BoldMembers[8]);
end;

function TGame._GetFontSize: Integer;
begin
  Result := M_FontSize.AsInteger;
end;

procedure TGame._SetFontSize(NewValue: Integer);
begin
  M_FontSize.AsInteger := NewValue;
end;

function TGame._Get_M_collecting: TBABoolean;
begin
  assert(ValidateMember('TGame', 'collecting', 9, TBABoolean));
  Result := TBABoolean(BoldMembers[9]);
end;

function TGame._Getcollecting: Boolean;
begin
  Result := M_collecting.AsBoolean;
end;

procedure TGame._Setcollecting(NewValue: Boolean);
begin
  M_collecting.AsBoolean := NewValue;
end;

function TGame._GetCell: TCellList;
begin
  assert(ValidateMember('TGame', 'Cell', 10, TCellList));
  Result := TCellList(BoldMembers[10]);
end;

function TGame._Getcoord: TCellList;
begin
  assert(ValidateMember('TGame', 'coord', 11, TCellList));
  Result := TCellList(BoldMembers[11]);
end;

function TGame._Get_Q_coord(x: Integer; y: Integer): TCell;
var
  TempResult: TBoldObject;
  TempList: TBoldMemberList;
  Q_x: TBAInteger;
  Q_y: TBAInteger;
begin
  TempList := TBoldMemberList.Create;
  TempList.CloneMembers := false;
  Q_x := TBAInteger.Create;
  Q_y := TBAInteger.Create;
  try
    Q_x.AsInteger := x;
    TempList.add(Q_x);
    Q_y.AsInteger := y;
    TempList.add(Q_y);
    TempResult := M_coord.GetByIndex(TempList);
    assert(not assigned(TempResult) or (TempResult is TCell), 'Illegal object in multilink');
    result := TCell(TempResult);
  finally
    TempList.Free;
    Q_x.Free;
    Q_y.Free;
  end;
end;

procedure TGameList.Add(NewObject: TGame);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TGameList.IndexOf(anObject: TGame): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TGameList.Includes(anObject: TGame) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TGameList.AddNew: TGame;
begin
  result := TGame(InternalAddNew);
end;

procedure TGameList.Insert(index: Integer; NewObject: TGame);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TGameList.GetBoldObject(index: Integer): TGame;
begin
  result := TGame(GetElement(index));
end;

procedure TGameList.SetBoldObject(index: Integer; NewObject: TGame);
begin;
  SetElement(index, NewObject);
end;

function TGame.GetDeriveMethodForMember(Member: TBoldMember): TBoldDeriveAndResubscribe;
begin
  if (Member = M_board) then result := _board_DeriveAndSubscribe else
  result := inherited GetDeriveMethodForMember(Member);
end;

function TGame.GetReverseDeriveMethodForMember(Member: TBoldMember): TBoldReverseDerive;
begin
  result := inherited GetReverseDeriveMethodForMember(Member);
  if not assigned(result) and (Member = M_board) then result := _board_ReverseDerive;
end;

function GeneratedCodeCRC: String;
begin
  result := '2017684102';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('Cell', TCellList);
  BoldObjectListClasses.AddObjectEntry('Game', TGameList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('Cell', TCell);
  BoldObjectClasses.AddObjectEntry('Game', TGame);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('ConwayClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.

