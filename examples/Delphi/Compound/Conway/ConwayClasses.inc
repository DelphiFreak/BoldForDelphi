{**********************************************************}
   {                                                          }
   {       Bold for Delphi Stub File                          }
   {                                                          }
   {       Autogenerated file for method implementations      }
   {                                                          }
   {**********************************************************}

// 
{$INCLUDE ConwayClasses_Interface.inc}

const
  ACTIVECELL: char = '*';
  INACTIVECELL:char = ' ';
  NOCELL:char = ' ';

procedure TGame.Tick;
var
  i: integer;
  CellCount: integer;
begin
  BoldSystem.StartTransaction;
  // Increase generations
  Generations := Generations + 1;
  InactiveCount := 0;
  CellCount := Cell.Count - 1;
  // Get intermediate value
  for i := 0 to CellCount do
    Cell[i].CalculateIntermediate;
  // Update board
  for i := 0 to CellCount do
    Cell[i].UpdateActive;
  BoldSystem.CommitTransaction;

  // Remove unused cells based on some simple rule
  if (Cell.Count > 0) and ((InactiveCount / Cell.Count) > 0.8) then
    GarbageCollect;
end;

procedure TGame.ClearCells;
begin
  // Delete all cells
  BoldSystem.StartTransaction;
  while Cell.Count > 0 do
    Cell[0].Delete;
  BoldSystem.CommitTransaction;
  ResetBounds;
end;

procedure TGame._board_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
var
  Universe: TStringList;
  s, EmptyRow: string;
  StringPos, i, y: integer;
  aCell: TCell;
  Bounds: TRect;
begin
  // Place relevant subscriptions
  // - the multilink
  // - active state of all cells
  Cell.DefaultSubscribe(Subscriber, breResubscribe);
  for i := 0 to Cell.Count - 1 do
    Cell[i].M_Active.DefaultSubscribe(Subscriber);

  Bounds := GetBounds;
  Universe := TStringList.Create;
  EmptyRow := StringOfChar(NOCELL, xSize);
  for y := Bounds.Top to Bounds.Bottom do
    Universe.Add(EmptyRow);

  for i := 0 to Cell.Count - 1 do
  begin
    aCell := Cell[i];
    StringPos := aCell.y - Bounds.Top;
    s := Universe.Strings[StringPos];
    s[aCell.x - Bounds.Left + 1] := aCell.AsString[1];
    Universe[StringPos] := s;
  end;

  m_Board.AsString := Universe.Text;
  Universe.Free;
end;

procedure TGame._board_ReverseDerive(DerivedObject: TObject);
var
  EmptyRow,
  s: string;
  x, y: integer;
  Strings: TStringList;
  aCell: TCell;
  ActiveSpot: boolean;
begin
  ClearCells;
  Strings := TStringList.Create;
  Strings.Text := Board;
  yMax := Strings.Count;
  for y := 0 to Strings.Count - 1 do
    if xMax < Length(Strings[y]) - 1 then
      xMax := Length(Strings[y]) - 1;

  BoldSystem.StartTransaction;
  EmptyRow := StringOfChar(INACTIVECELL, xSize);
  //EmptyRow := StringOfChar(' ', xSize);
  // Traverse all lines
  for y := 0 to Strings.Count - 1 do
  begin
    s := Strings[y] + EmptyRow;
    // for all columns...
    for x := 0 to xMax do
    begin
      aCell := Coord[x, y];
      ActiveSpot := S[x + 1] = ACTIVECELL;
      if Assigned(aCell) then
        aCell.Active := ActiveSpot
      else if ActiveSpot then
      begin
        aCell := TCell(Cell.AddNew);
        aCell.SetupCell(x, y);
        aCell.Active := True;
      end;
      if Assigned(aCell) then
        aCell.EnsureNeighbours;
    end;
  end;
  BoldSystem.CommitTransaction;
  Strings.Free;
end;

procedure TGame.UpdateBounds(x: integer; y: integer);
begin
  if y > yMax then yMax := y;
  if y < yMin then yMin := y;
  if x > xMax then xMax := x;
  if x < xMin then xMin := x;
end;

procedure TGame.GarbageCollect;
var
  i: integer;
begin
  // Used for GUI feedback
  Collecting := True;
  TBoldQueueable.DisplayAll;

  BoldSystem.StartTransaction;
  for i := Cell.Count - 1 downto 0 do
    if Cell[i].AllowRemove then
      Cell[i].Delete;
  BoldSystem.CommitTransaction;
  RefreshBounds;

  // Used for GUI feedback
  Collecting := False;
  TBoldQueueable.DisplayAll;
end;

procedure TGame.RefreshBounds;
var
  temp,
  i: integer;
begin
  temp := yMax;
  yMax := yMin;
  yMin := Temp;
  temp := xMax;
  xMax := xMin;
  xMin := Temp;
  for i := 0 to Cell.Count - 1 do
    UpdateBounds(Cell[i].x, Cell[i].y);
end;

function TGame.GetBounds: TRect;
begin
  Result.Left := xMin;
  Result.Right := xMax;
  Result.Top := yMin;
  Result.Bottom := yMax;
end;

procedure TGame.ResetBounds;
begin
  xMax := 0;
  xMin := 0;
  yMax := 0;
  yMin := 0;
end;

procedure TCell.SetupCell(x: integer; y: integer);
begin
  Self.x := x;
  Self.y := y;
  Game.UpdateBounds(x, y);
  Game.m_Coord.Add(Self);
end;

procedure TCell.CalculateIntermediate;
begin
  // What will happen in the next generation?
  // New cell is born
  if not Active and (Neighbours = 3) then
    Intermediate := True
  // A cell survives
  else if Active and (Neighbours in [2, 3]) then
    Intermediate := True
  // The other cells will be inactive
  else begin
    Game.InactiveCount := Game.InactiveCount + 1;
    Intermediate := False;
  end;
end;

procedure TCell.UpdateActive;
begin
  // Make the caluclated value the active for next generation
  Active := Intermediate;
  EnsureNeighbours;
end;

procedure TCell.EnsureNeighbours;
begin
  if not NeighboursEnsured and Active then
  begin
    EnsureCell(cLeft,      x-1, y);
    EnsureCell(cRight,     x+1, y);
    EnsureCell(cUp,        x,   y-1);
    EnsureCell(cDown,      x,   y+1);
    EnsureCell(cUpRight,   x+1, y-1);
    EnsureCell(cUpLeft,    x-1, y-1);
    EnsureCell(cDownLeft,  x-1, y+1);
    EnsureCell(cDownRight, x+1, y+1);
    NeighboursEnsured := True;
  end;
end;

function TCell.EnsureCell(aCell: TCell; x: integer; y: integer): TCell;
begin
  if not Assigned(aCell) then
  begin
    Result := TCell(Game.Cell.AddNew);
    Result.SetupCell(x, y);
  end
  else
    Result := aCell;
end;

function TCell.AllowRemove: boolean;
begin
  Result := not Active and (Neighbours = 0);
end;

procedure TCell.PrepareDelete;
begin
  inherited;
  UnensureNeighbours;
end;

procedure TCell.UnensureNeighbours;
begin
  UnensureCell(cLeft);
  UnensureCell(cRight);
  UnensureCell(cUp);
  UnensureCell(cDown);

  UnensureCell(cDownRight);
  UnensureCell(cDownLeft);
  UnensureCell(cUpRight);
  UnensureCell(cUpLeft);
end;

procedure TCell.UnensureCell(aCell: TCell);
begin
  if Assigned(aCell) then
    aCell.NeighboursEnsured := False;
end;

procedure TCell.NeighboursNotEnsured;
begin
end;

