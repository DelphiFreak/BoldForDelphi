{**********************************************************}
   {                                                          }
   {       Bold for Delphi Stub File                          }
   {                                                          }
   {       Autogenerated file for method implementations      }
   {                                                          }
   {**********************************************************}

// 
{$INCLUDE ProdStructClasses_Interface.inc}

{
  This example shows derivation with code.
  The most effective way in this particular example would do
  to use OCL derivation in the model.
  However, this example uses pure basic code
}


procedure TProduct._TotalCost_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
begin
  {Calculate value and place subscriptions on derived attribute.
  Product is an abstact class and there is no common code.}
end;

procedure TAssembly._TotalCost_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
var
  I: Integer;
  C: Currency;
begin
  {Cost of Assembly is totalCost of each part + AssembyCost}
  {Calculate value and place subscriptions on derived attribute.}
  {Note, this example show how you iterate over all items in a multi relation}

  m_AssemblyCost.DefaultSubscribe(Subscriber);
  C := assemblyCost;

  {NB! SubscribeToExpression has Resubscribe set to TRUE to ensure that we are called again
  if the list changes. This is needed so we can place subscriptions on new parts.}

  SubscribeToExpression('parts', Subscriber, True);

  for I := 0 to parts.Count - 1 do
  begin
    C := C + parts[I].totalCost;
    Parts[I].SubscribeToExpression('totalCost', Subscriber, False);
  end;
  M_TotalCost.AsCurrency := C;

  {
    Now, having said all that, you could have derived the same in OCL:
    assemblyCost + parts.totalCost->sum
    No code would have been required to achieve the derivation.
    However, we'd have lost an opportunity to show you how it's done in code :)
  }
end;

procedure TSimple_Product._TotalCost_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
begin
  {Cost of simple product is simply productioncost}
  M_TotalCost.AsCurrency := productionCost;
  SubscribeToExpression('productionCost', Subscriber, False);
end;


