(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2002-04-05 17:08:33         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit ProdStructClasses;

{$DEFINE ProdStructClasses_unitheader}
{$INCLUDE ProdStructClasses_Interface.inc}

uses
  // implementation uses
  // implementation dependencies
  // other
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }

{$INCLUDE ProdStructClasses.inc}

const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TProdStructClassesRoot }

procedure TProdStructClassesRootList.Add(NewObject: TProdStructClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TProdStructClassesRootList.IndexOf(anObject: TProdStructClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TProdStructClassesRootList.Includes(anObject: TProdStructClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TProdStructClassesRootList.AddNew: TProdStructClassesRoot;
begin
  result := TProdStructClassesRoot(InternalAddNew);
end;

procedure TProdStructClassesRootList.Insert(index: Integer; NewObject: TProdStructClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TProdStructClassesRootList.GetBoldObject(index: Integer): TProdStructClassesRoot;
begin
  result := TProdStructClassesRoot(GetElement(index));
end;

procedure TProdStructClassesRootList.SetBoldObject(index: Integer; NewObject: TProdStructClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{ TPartOfParts }

function TPartOfParts._Get_M_Parts: TBoldObjectReference;
begin
  assert(ValidateMember('TPartOfParts', 'Parts', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function TPartOfParts._GetParts: TProduct;
begin
  assert(not assigned(M_Parts.BoldObject) or (M_Parts.BoldObject is TProduct), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'Parts', M_Parts.BoldObject.ClassName, 'TProduct']));
  Result := TProduct(M_Parts.BoldObject);
end;

function TPartOfParts._Get_M_PartOf: TBoldObjectReference;
begin
  assert(ValidateMember('TPartOfParts', 'PartOf', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function TPartOfParts._GetPartOf: TAssembly;
begin
  assert(not assigned(M_PartOf.BoldObject) or (M_PartOf.BoldObject is TAssembly), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'PartOf', M_PartOf.BoldObject.ClassName, 'TAssembly']));
  Result := TAssembly(M_PartOf.BoldObject);
end;

procedure TPartOfPartsList.Add(NewObject: TPartOfParts);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TPartOfPartsList.IndexOf(anObject: TPartOfParts): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TPartOfPartsList.Includes(anObject: TPartOfParts) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TPartOfPartsList.AddNew: TPartOfParts;
begin
  result := TPartOfParts(InternalAddNew);
end;

procedure TPartOfPartsList.Insert(index: Integer; NewObject: TPartOfParts);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TPartOfPartsList.GetBoldObject(index: Integer): TPartOfParts;
begin
  result := TPartOfParts(GetElement(index));
end;

procedure TPartOfPartsList.SetBoldObject(index: Integer; NewObject: TPartOfParts);
begin;
  SetElement(index, NewObject);
end;

{ TProduct }

function TProduct._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TProduct', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TProduct._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TProduct._SetName(NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function TProduct._Get_M_Price: TBACurrency;
begin
  assert(ValidateMember('TProduct', 'Price', 1, TBACurrency));
  Result := TBACurrency(BoldMembers[1]);
end;

function TProduct._GetPrice: Currency;
begin
  Result := M_Price.AsCurrency;
end;

procedure TProduct._SetPrice(NewValue: Currency);
begin
  M_Price.AsCurrency := NewValue;
end;

function TProduct._Get_M_TotalCost: TBACurrency;
begin
  assert(ValidateMember('TProduct', 'TotalCost', 2, TBACurrency));
  Result := TBACurrency(BoldMembers[2]);
end;

function TProduct._GetTotalCost: Currency;
begin
  Result := M_TotalCost.AsCurrency;
end;

function TProduct._GetPartOf: TAssemblyList;
begin
  assert(ValidateMember('TProduct', 'PartOf', 3, TAssemblyList));
  Result := TAssemblyList(BoldMembers[3]);
end;

function TProduct._GetPartOfPartOfParts: TPartOfPartsList;
begin
  assert(ValidateMember('TProduct', 'PartOfPartOfParts', 4, TPartOfPartsList));
  Result := TPartOfPartsList(BoldMembers[4]);
end;

procedure TProductList.Add(NewObject: TProduct);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TProductList.IndexOf(anObject: TProduct): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TProductList.Includes(anObject: TProduct) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TProductList.AddNew: TProduct;
begin
  result := TProduct(InternalAddNew);
end;

procedure TProductList.Insert(index: Integer; NewObject: TProduct);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TProductList.GetBoldObject(index: Integer): TProduct;
begin
  result := TProduct(GetElement(index));
end;

procedure TProductList.SetBoldObject(index: Integer; NewObject: TProduct);
begin;
  SetElement(index, NewObject);
end;

function TProduct.GetDeriveMethodForMember(Member: TBoldMember): TBoldDeriveAndResubscribe;
begin
  if (Member = M_TotalCost) then result := _TotalCost_DeriveAndSubscribe else
  result := inherited GetDeriveMethodForMember(Member);
end;

function TProduct.GetReverseDeriveMethodForMember(Member: TBoldMember): TBoldReverseDerive;
begin
  result := inherited GetReverseDeriveMethodForMember(Member);
end;

{ TAssembly }

function TAssembly._Get_M_AssemblyCost: TBACurrency;
begin
  assert(ValidateMember('TAssembly', 'AssemblyCost', 5, TBACurrency));
  Result := TBACurrency(BoldMembers[5]);
end;

function TAssembly._GetAssemblyCost: Currency;
begin
  Result := M_AssemblyCost.AsCurrency;
end;

procedure TAssembly._SetAssemblyCost(NewValue: Currency);
begin
  M_AssemblyCost.AsCurrency := NewValue;
end;

function TAssembly._GetParts: TProductList;
begin
  assert(ValidateMember('TAssembly', 'Parts', 6, TProductList));
  Result := TProductList(BoldMembers[6]);
end;

function TAssembly._GetPartsPartOfParts: TPartOfPartsList;
begin
  assert(ValidateMember('TAssembly', 'PartsPartOfParts', 7, TPartOfPartsList));
  Result := TPartOfPartsList(BoldMembers[7]);
end;

procedure TAssemblyList.Add(NewObject: TAssembly);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TAssemblyList.IndexOf(anObject: TAssembly): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TAssemblyList.Includes(anObject: TAssembly) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TAssemblyList.AddNew: TAssembly;
begin
  result := TAssembly(InternalAddNew);
end;

procedure TAssemblyList.Insert(index: Integer; NewObject: TAssembly);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TAssemblyList.GetBoldObject(index: Integer): TAssembly;
begin
  result := TAssembly(GetElement(index));
end;

procedure TAssemblyList.SetBoldObject(index: Integer; NewObject: TAssembly);
begin;
  SetElement(index, NewObject);
end;

{ TSimple_Product }

function TSimple_Product._Get_M_ProductionCost: TBACurrency;
begin
  assert(ValidateMember('TSimple_Product', 'ProductionCost', 5, TBACurrency));
  Result := TBACurrency(BoldMembers[5]);
end;

function TSimple_Product._GetProductionCost: Currency;
begin
  Result := M_ProductionCost.AsCurrency;
end;

procedure TSimple_Product._SetProductionCost(NewValue: Currency);
begin
  M_ProductionCost.AsCurrency := NewValue;
end;

procedure TSimple_ProductList.Add(NewObject: TSimple_Product);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TSimple_ProductList.IndexOf(anObject: TSimple_Product): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TSimple_ProductList.Includes(anObject: TSimple_Product) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TSimple_ProductList.AddNew: TSimple_Product;
begin
  result := TSimple_Product(InternalAddNew);
end;

procedure TSimple_ProductList.Insert(index: Integer; NewObject: TSimple_Product);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TSimple_ProductList.GetBoldObject(index: Integer): TSimple_Product;
begin
  result := TSimple_Product(GetElement(index));
end;

procedure TSimple_ProductList.SetBoldObject(index: Integer; NewObject: TSimple_Product);
begin;
  SetElement(index, NewObject);
end;

function GeneratedCodeCRC: String;
begin
  result := '432794881';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('ProdStructClassesRoot', TProdStructClassesRootList);
  BoldObjectListClasses.AddObjectEntry('PartOfParts', TPartOfPartsList);
  BoldObjectListClasses.AddObjectEntry('Product', TProductList);
  BoldObjectListClasses.AddObjectEntry('Assembly', TAssemblyList);
  BoldObjectListClasses.AddObjectEntry('Simple_Product', TSimple_ProductList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('ProdStructClassesRoot', TProdStructClassesRoot);
  BoldObjectClasses.AddObjectEntry('PartOfParts', TPartOfParts);
  BoldObjectClasses.AddObjectEntry('Product', TProduct);
  BoldObjectClasses.AddObjectEntry('Assembly', TAssembly);
  BoldObjectClasses.AddObjectEntry('Simple_Product', TSimple_Product);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('ProdStructClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.

 