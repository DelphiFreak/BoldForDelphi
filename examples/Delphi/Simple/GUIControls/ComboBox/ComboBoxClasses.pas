(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2002-04-05 14:41:34         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit ComboBoxClasses;

{$DEFINE ComboBoxClasses_unitheader}
{$INCLUDE ComboBoxClasses_Interface.inc}

uses
  // implementation uses
  // implementation dependencies
  // other
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }

{$INCLUDE ComboBoxClasses.inc}

const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{ TFood }

function TFood._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TFood', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TFood._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TFood._SetName(NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function TFood._GetIsFavouredBy: TPersonList;
begin
  assert(ValidateMember('TFood', 'IsFavouredBy', 1, TPersonList));
  Result := TPersonList(BoldMembers[1]);
end;

procedure TFoodList.Add(NewObject: TFood);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TFoodList.IndexOf(anObject: TFood): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TFoodList.Includes(anObject: TFood) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TFoodList.AddNew: TFood;
begin
  result := TFood(InternalAddNew);
end;

procedure TFoodList.Insert(index: Integer; NewObject: TFood);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TFoodList.GetBoldObject(index: Integer): TFood;
begin
  result := TFood(GetElement(index));
end;

procedure TFoodList.SetBoldObject(index: Integer; NewObject: TFood);
begin;
  SetElement(index, NewObject);
end;

{ TPerson }

function TPerson._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TPerson', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TPerson._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TPerson._SetName(NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function TPerson._Get_M_AttendsSchool: TBAString;
begin
  assert(ValidateMember('TPerson', 'AttendsSchool', 1, TBAString));
  Result := TBAString(BoldMembers[1]);
end;

function TPerson._GetAttendsSchool: String;
begin
  Result := M_AttendsSchool.AsString;
end;

procedure TPerson._SetAttendsSchool(NewValue: String);
begin
  M_AttendsSchool.AsString := NewValue;
end;

function TPerson._Get_M_Major: TBAString;
begin
  assert(ValidateMember('TPerson', 'Major', 2, TBAString));
  Result := TBAString(BoldMembers[2]);
end;

function TPerson._GetMajor: String;
begin
  Result := M_Major.AsString;
end;

procedure TPerson._SetMajor(NewValue: String);
begin
  M_Major.AsString := NewValue;
end;

function TPerson._Get_M_FavouriteMusic: TBAString;
begin
  assert(ValidateMember('TPerson', 'FavouriteMusic', 3, TBAString));
  Result := TBAString(BoldMembers[3]);
end;

function TPerson._GetFavouriteMusic: String;
begin
  Result := M_FavouriteMusic.AsString;
end;

procedure TPerson._SetFavouriteMusic(NewValue: String);
begin
  M_FavouriteMusic.AsString := NewValue;
end;

function TPerson._Get_M_PreferredFood: TBoldObjectReference;
begin
  assert(ValidateMember('TPerson', 'PreferredFood', 4, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[4]);
end;

function TPerson._GetPreferredFood: TFood;
begin
  assert(not assigned(M_PreferredFood.BoldObject) or (M_PreferredFood.BoldObject is TFood), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'PreferredFood', M_PreferredFood.BoldObject.ClassName, 'TFood']));
  Result := TFood(M_PreferredFood.BoldObject);
end;

procedure TPerson._SetPreferredFood(value: TFood);
begin
  M_PreferredFood.BoldObject := value;
end;

procedure TPersonList.Add(NewObject: TPerson);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TPersonList.IndexOf(anObject: TPerson): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TPersonList.Includes(anObject: TPerson) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TPersonList.AddNew: TPerson;
begin
  result := TPerson(InternalAddNew);
end;

procedure TPersonList.Insert(index: Integer; NewObject: TPerson);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TPersonList.GetBoldObject(index: Integer): TPerson;
begin
  result := TPerson(GetElement(index));
end;

procedure TPersonList.SetBoldObject(index: Integer; NewObject: TPerson);
begin;
  SetElement(index, NewObject);
end;

{ TSchool }

function TSchool._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TSchool', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TSchool._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TSchool._SetName(NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

procedure TSchoolList.Add(NewObject: TSchool);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TSchoolList.IndexOf(anObject: TSchool): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TSchoolList.Includes(anObject: TSchool) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TSchoolList.AddNew: TSchool;
begin
  result := TSchool(InternalAddNew);
end;

procedure TSchoolList.Insert(index: Integer; NewObject: TSchool);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TSchoolList.GetBoldObject(index: Integer): TSchool;
begin
  result := TSchool(GetElement(index));
end;

procedure TSchoolList.SetBoldObject(index: Integer; NewObject: TSchool);
begin;
  SetElement(index, NewObject);
end;

function GeneratedCodeCRC: String;
begin
  result := '1616966516';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('Food', TFoodList);
  BoldObjectListClasses.AddObjectEntry('Person', TPersonList);
  BoldObjectListClasses.AddObjectEntry('School', TSchoolList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('Food', TFood);
  BoldObjectClasses.AddObjectEntry('Person', TPerson);
  BoldObjectClasses.AddObjectEntry('School', TSchool);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('ComboBoxClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.

