(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2002-04-05 15:18:32         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit TreeViewExampleClasses;

{$DEFINE TreeViewExampleClasses_unitheader}
{$INCLUDE TreeViewExampleClasses_Interface.inc}

uses
  // implementation uses
  // implementation dependencies
  // other
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }


const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{ TFrame }

function TFrame._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TFrame', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TFrame._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TFrame._SetName(NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function TFrame._Get_M_FrameSize: TBAInteger;
begin
  assert(ValidateMember('TFrame', 'FrameSize', 1, TBAInteger));
  Result := TBAInteger(BoldMembers[1]);
end;

function TFrame._GetFrameSize: Integer;
begin
  Result := M_FrameSize.AsInteger;
end;

procedure TFrame._SetFrameSize(NewValue: Integer);
begin
  M_FrameSize.AsInteger := NewValue;
end;

function TFrame._GetPartOf: TMTBList;
begin
  assert(ValidateMember('TFrame', 'PartOf', 2, TMTBList));
  Result := TMTBList(BoldMembers[2]);
end;

procedure TFrameList.Add(NewObject: TFrame);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TFrameList.IndexOf(anObject: TFrame): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TFrameList.Includes(anObject: TFrame) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TFrameList.AddNew: TFrame;
begin
  result := TFrame(InternalAddNew);
end;

procedure TFrameList.Insert(index: Integer; NewObject: TFrame);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TFrameList.GetBoldObject(index: Integer): TFrame;
begin
  result := TFrame(GetElement(index));
end;

procedure TFrameList.SetBoldObject(index: Integer; NewObject: TFrame);
begin;
  SetElement(index, NewObject);
end;

{ TMTB }

function TMTB._Get_M_Name: TBAString;
begin
  assert(ValidateMember('TMTB', 'Name', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TMTB._GetName: String;
begin
  Result := M_Name.AsString;
end;

procedure TMTB._SetName(NewValue: String);
begin
  M_Name.AsString := NewValue;
end;

function TMTB._GetConsistsOf: TPartsList;
begin
  assert(ValidateMember('TMTB', 'ConsistsOf', 1, TPartsList));
  Result := TPartsList(BoldMembers[1]);
end;

function TMTB._GetMTB_Comps: TMTB_CompsList;
begin
  assert(ValidateMember('TMTB', 'MTB_Comps', 2, TMTB_CompsList));
  Result := TMTB_CompsList(BoldMembers[2]);
end;

function TMTB._Get_M_BuiltAround: TBoldObjectReference;
begin
  assert(ValidateMember('TMTB', 'BuiltAround', 3, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[3]);
end;

function TMTB._GetBuiltAround: TFrame;
begin
  assert(not assigned(M_BuiltAround.BoldObject) or (M_BuiltAround.BoldObject is TFrame), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'BuiltAround', M_BuiltAround.BoldObject.ClassName, 'TFrame']));
  Result := TFrame(M_BuiltAround.BoldObject);
end;

procedure TMTB._SetBuiltAround(value: TFrame);
begin
  M_BuiltAround.BoldObject := value;
end;

procedure TMTBList.Add(NewObject: TMTB);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TMTBList.IndexOf(anObject: TMTB): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TMTBList.Includes(anObject: TMTB) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TMTBList.AddNew: TMTB;
begin
  result := TMTB(InternalAddNew);
end;

procedure TMTBList.Insert(index: Integer; NewObject: TMTB);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TMTBList.GetBoldObject(index: Integer): TMTB;
begin
  result := TMTB(GetElement(index));
end;

procedure TMTBList.SetBoldObject(index: Integer; NewObject: TMTB);
begin;
  SetElement(index, NewObject);
end;

{ TMTB_Comps }

function TMTB_Comps._Get_M_PartOf: TBoldObjectReference;
begin
  assert(ValidateMember('TMTB_Comps', 'PartOf', 0, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[0]);
end;

function TMTB_Comps._GetPartOf: TMTB;
begin
  assert(not assigned(M_PartOf.BoldObject) or (M_PartOf.BoldObject is TMTB), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'PartOf', M_PartOf.BoldObject.ClassName, 'TMTB']));
  Result := TMTB(M_PartOf.BoldObject);
end;

function TMTB_Comps._Get_M_ConsistsOf: TBoldObjectReference;
begin
  assert(ValidateMember('TMTB_Comps', 'ConsistsOf', 1, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[1]);
end;

function TMTB_Comps._GetConsistsOf: TParts;
begin
  assert(not assigned(M_ConsistsOf.BoldObject) or (M_ConsistsOf.BoldObject is TParts), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'ConsistsOf', M_ConsistsOf.BoldObject.ClassName, 'TParts']));
  Result := TParts(M_ConsistsOf.BoldObject);
end;

procedure TMTB_CompsList.Add(NewObject: TMTB_Comps);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TMTB_CompsList.IndexOf(anObject: TMTB_Comps): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TMTB_CompsList.Includes(anObject: TMTB_Comps) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TMTB_CompsList.AddNew: TMTB_Comps;
begin
  result := TMTB_Comps(InternalAddNew);
end;

procedure TMTB_CompsList.Insert(index: Integer; NewObject: TMTB_Comps);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TMTB_CompsList.GetBoldObject(index: Integer): TMTB_Comps;
begin
  result := TMTB_Comps(GetElement(index));
end;

procedure TMTB_CompsList.SetBoldObject(index: Integer; NewObject: TMTB_Comps);
begin;
  SetElement(index, NewObject);
end;

{ TParts }

function TParts._Get_M_Model: TBAString;
begin
  assert(ValidateMember('TParts', 'Model', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TParts._GetModel: String;
begin
  Result := M_Model.AsString;
end;

procedure TParts._SetModel(NewValue: String);
begin
  M_Model.AsString := NewValue;
end;

function TParts._GetPartOf: TMTBList;
begin
  assert(ValidateMember('TParts', 'PartOf', 1, TMTBList));
  Result := TMTBList(BoldMembers[1]);
end;

function TParts._GetMTB_Comps: TMTB_CompsList;
begin
  assert(ValidateMember('TParts', 'MTB_Comps', 2, TMTB_CompsList));
  Result := TMTB_CompsList(BoldMembers[2]);
end;

procedure TPartsList.Add(NewObject: TParts);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TPartsList.IndexOf(anObject: TParts): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TPartsList.Includes(anObject: TParts) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TPartsList.AddNew: TParts;
begin
  result := TParts(InternalAddNew);
end;

procedure TPartsList.Insert(index: Integer; NewObject: TParts);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TPartsList.GetBoldObject(index: Integer): TParts;
begin
  result := TParts(GetElement(index));
end;

procedure TPartsList.SetBoldObject(index: Integer; NewObject: TParts);
begin;
  SetElement(index, NewObject);
end;

{ TBrake }

procedure TBrakeList.Add(NewObject: TBrake);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBrakeList.IndexOf(anObject: TBrake): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBrakeList.Includes(anObject: TBrake) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBrakeList.AddNew: TBrake;
begin
  result := TBrake(InternalAddNew);
end;

procedure TBrakeList.Insert(index: Integer; NewObject: TBrake);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBrakeList.GetBoldObject(index: Integer): TBrake;
begin
  result := TBrake(GetElement(index));
end;

procedure TBrakeList.SetBoldObject(index: Integer; NewObject: TBrake);
begin;
  SetElement(index, NewObject);
end;

{ TGear }

procedure TGearList.Add(NewObject: TGear);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TGearList.IndexOf(anObject: TGear): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TGearList.Includes(anObject: TGear) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TGearList.AddNew: TGear;
begin
  result := TGear(InternalAddNew);
end;

procedure TGearList.Insert(index: Integer; NewObject: TGear);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TGearList.GetBoldObject(index: Integer): TGear;
begin
  result := TGear(GetElement(index));
end;

procedure TGearList.SetBoldObject(index: Integer; NewObject: TGear);
begin;
  SetElement(index, NewObject);
end;

{ TWheel }

procedure TWheelList.Add(NewObject: TWheel);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TWheelList.IndexOf(anObject: TWheel): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TWheelList.Includes(anObject: TWheel) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TWheelList.AddNew: TWheel;
begin
  result := TWheel(InternalAddNew);
end;

procedure TWheelList.Insert(index: Integer; NewObject: TWheel);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TWheelList.GetBoldObject(index: Integer): TWheel;
begin
  result := TWheel(GetElement(index));
end;

procedure TWheelList.SetBoldObject(index: Integer; NewObject: TWheel);
begin;
  SetElement(index, NewObject);
end;

function GeneratedCodeCRC: String;
begin
  result := '292865628';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('Frame', TFrameList);
  BoldObjectListClasses.AddObjectEntry('MTB', TMTBList);
  BoldObjectListClasses.AddObjectEntry('MTB_Comps', TMTB_CompsList);
  BoldObjectListClasses.AddObjectEntry('Parts', TPartsList);
  BoldObjectListClasses.AddObjectEntry('Brake', TBrakeList);
  BoldObjectListClasses.AddObjectEntry('Gear', TGearList);
  BoldObjectListClasses.AddObjectEntry('Wheel', TWheelList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('Frame', TFrame);
  BoldObjectClasses.AddObjectEntry('MTB', TMTB);
  BoldObjectClasses.AddObjectEntry('MTB_Comps', TMTB_Comps);
  BoldObjectClasses.AddObjectEntry('Parts', TParts);
  BoldObjectClasses.AddObjectEntry('Brake', TBrake);
  BoldObjectClasses.AddObjectEntry('Gear', TGear);
  BoldObjectClasses.AddObjectEntry('Wheel', TWheel);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('TreeViewExampleClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.

 