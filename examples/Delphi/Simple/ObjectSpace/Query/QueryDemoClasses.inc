    {**********************************************************}
    {                                                          }
    {       Bold for Delphi Stub File                          }
    {                                                          }
    {       Autogenerated file for method implementations      }
    {                                                          }
    {**********************************************************}

{$INCLUDE QueryDemoClasses_Interface.inc}

function TThing.ReceiveQueryFromOwned(Originator: TObject; OriginalEvent: TBoldEvent; const Args: array of const; Subscriber: TBoldSubscriber) : Boolean;

  function ValidateMaxParts(aThing: TThing): Boolean;
  // Don't allow more than four parts
  begin
    result := true;
    if aThing.parts.Count >= 4 then
    begin
      result := False;
      SetBoldLastFailureReason(TBoldFailureReason.Create('A Thing can not have more than four parts', nil));
    end;
  end;

  function ValidatePartOfSelf(Thing1, Thing2: TThing): Boolean;
  // Don't allow an object to be part of itself
  begin
    result := true;
    if Thing1.IsTransitivePartOf(Thing2) then
    begin
      result := False;
      SetBoldLastFailureReason(TBoldFailureReason.Create('A Thing can not be part of itself', nil));
    end;
  end;

  function GrantQueryParts(aThing: TThing; OriginalEvent: TBoldEvent; const Args: array of const) : Boolean;
  begin
    result := true;
    if OriginalEvent = bqMayInsert then
      result := ValidatePartOfSelf(aThing, (Args[1].VObject as TBoldObjectLocator).EnsuredBoldObject as TThing) and
                ValidateMaxParts(aThing)
    // Can we replace an element in parts with this object?
    else if OriginalEvent = bqMayReplace then
      result := ValidatePartOfSelf(aThing, (Args[1].VObject as TBoldObjectLocator).EnsuredBoldObject as TThing);
  end;

  function GrantQueryPartOf(aThing: TThing; const Args: array of const) : Boolean;
  begin
    // Can we set 'partof' to the object? (i.e. can we insert ourself into 'parts' of the object?)
    result := ValidatePartOfSelf((Args[0].VObject as TBoldObjectLocator).EnsuredBoldObject as TThing, self) and
              ValidateMaxParts((Args[0].VObject as TBoldObjectLocator).EnsuredBoldObject as TThing);
  end;

begin
  // This function is called when someone wants to know if it can access one of this object's members.
  // Return True to allow the operation and False to disallow it.

  result := True; // Default. Allow all operations.

  if (Originator = parts) then
    result := GrantQueryParts(self, OriginalEvent, Args)

  else if (Originator = M_partof) and
          (OriginalEvent = bqMaySetValue) then
    result := GrantQueryPartOf(self, Args)

  else if (Originator = M_Name) and
          (OriginalEvent = bqMaySetValue) and
    // Can we set the 'Name' attribute to this?
          // Disallow calling things 'It'.
          (string(Args[0].VAnsiString) = 'It') then
  begin
    result := False;
    SetBoldLastFailureReason(TBoldFailureReason.Create('A Thing can not be called It', nil));
  end

  else if (Originator = M_Name) and
          (OriginalEvent = bqMayUpdate) and
    // Can we update the 'Name' attribute?
          // Disallow saving empty names.
          (Name = '') then
  begin
    result := False;
    SetBoldLastFailureReason(TBoldFailureReason.Create('Can not save a thing with empty name', nil));
  end

end;


function TThing.IsTransitivePartOf(aThing: TThing): Boolean;
begin
  result := (aThing = self) or (assigned(partof) and partof.IsTransitivePartOf(aThing));
end;


