(*****************************************)
(*      This file is autogenerated       *)
(*   Any manual changes will be LOST!    *)
(*****************************************)
(* Generated 2002-04-05 16:11:11         *)
(*****************************************)
(* This file should be stored in the     *)
(* same directory as the form/datamodule *)
(* with the corresponding model          *)
(*****************************************)
(* Copyright notice:                     *)
(*                                       *)
(*****************************************)

unit ReverseDeriveExampleClasses;

{$DEFINE ReverseDeriveExampleClasses_unitheader}
{$INCLUDE ReverseDeriveExampleClasses_Interface.inc}

uses
  // implementation uses
  // implementation dependencies
  // other
  BoldGeneratedCodeDictionary;

{ Includefile for methodimplementations }

{$INCLUDE ReverseDeriveExampleClasses.inc}

const
  BoldMemberAssertInvalidObjectType: string = 'Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)';

{ TBusinessClassesRoot }

procedure TBusinessClassesRootList.Add(NewObject: TBusinessClassesRoot);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TBusinessClassesRootList.IndexOf(anObject: TBusinessClassesRoot): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TBusinessClassesRootList.Includes(anObject: TBusinessClassesRoot) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TBusinessClassesRootList.AddNew: TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(InternalAddNew);
end;

procedure TBusinessClassesRootList.Insert(index: Integer; NewObject: TBusinessClassesRoot);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TBusinessClassesRootList.GetBoldObject(index: Integer): TBusinessClassesRoot;
begin
  result := TBusinessClassesRoot(GetElement(index));
end;

procedure TBusinessClassesRootList.SetBoldObject(index: Integer; NewObject: TBusinessClassesRoot);
begin;
  SetElement(index, NewObject);
end;

{ TFamily }

function TFamily._Get_M_familyName: TBAString;
begin
  assert(ValidateMember('TFamily', 'familyName', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TFamily._GetfamilyName: String;
begin
  Result := M_familyName.AsString;
end;

procedure TFamily._SetfamilyName(NewValue: String);
begin
  M_familyName.AsString := NewValue;
end;

function TFamily._GetfamilyMembers: TPersonList;
begin
  assert(ValidateMember('TFamily', 'familyMembers', 1, TPersonList));
  Result := TPersonList(BoldMembers[1]);
end;

procedure TFamilyList.Add(NewObject: TFamily);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TFamilyList.IndexOf(anObject: TFamily): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TFamilyList.Includes(anObject: TFamily) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TFamilyList.AddNew: TFamily;
begin
  result := TFamily(InternalAddNew);
end;

procedure TFamilyList.Insert(index: Integer; NewObject: TFamily);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TFamilyList.GetBoldObject(index: Integer): TFamily;
begin
  result := TFamily(GetElement(index));
end;

procedure TFamilyList.SetBoldObject(index: Integer; NewObject: TFamily);
begin;
  SetElement(index, NewObject);
end;

{ TFont }

function TFont._Get_M_blink: TBABoolean;
begin
  assert(ValidateMember('TFont', 'blink', 0, TBABoolean));
  Result := TBABoolean(BoldMembers[0]);
end;

function TFont._Getblink: Boolean;
begin
  Result := M_blink.AsBoolean;
end;

procedure TFont._Setblink(NewValue: Boolean);
begin
  M_blink.AsBoolean := NewValue;
end;

function TFont._Get_M_bold: TBABoolean;
begin
  assert(ValidateMember('TFont', 'bold', 1, TBABoolean));
  Result := TBABoolean(BoldMembers[1]);
end;

function TFont._Getbold: Boolean;
begin
  Result := M_bold.AsBoolean;
end;

procedure TFont._Setbold(NewValue: Boolean);
begin
  M_bold.AsBoolean := NewValue;
end;

function TFont._Get_M_noValues: TBABoolean;
begin
  assert(ValidateMember('TFont', 'noValues', 2, TBABoolean));
  Result := TBABoolean(BoldMembers[2]);
end;

function TFont._GetnoValues: Boolean;
begin
  Result := M_noValues.AsBoolean;
end;

procedure TFont._SetnoValues(NewValue: Boolean);
begin
  M_noValues.AsBoolean := NewValue;
end;

function TFont._Get_M_underline: TBABoolean;
begin
  assert(ValidateMember('TFont', 'underline', 3, TBABoolean));
  Result := TBABoolean(BoldMembers[3]);
end;

function TFont._Getunderline: Boolean;
begin
  Result := M_underline.AsBoolean;
end;

procedure TFont._Setunderline(NewValue: Boolean);
begin
  M_underline.AsBoolean := NewValue;
end;

function TFont._Get_M_resultString: TBAString;
begin
  assert(ValidateMember('TFont', 'resultString', 4, TBAString));
  Result := TBAString(BoldMembers[4]);
end;

function TFont._GetresultString: String;
begin
  Result := M_resultString.AsString;
end;

function TFont._Get_M_name: TBAString;
begin
  assert(ValidateMember('TFont', 'name', 5, TBAString));
  Result := TBAString(BoldMembers[5]);
end;

function TFont._Getname: String;
begin
  Result := M_name.AsString;
end;

procedure TFont._Setname(NewValue: String);
begin
  M_name.AsString := NewValue;
end;

procedure TFontList.Add(NewObject: TFont);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TFontList.IndexOf(anObject: TFont): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TFontList.Includes(anObject: TFont) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TFontList.AddNew: TFont;
begin
  result := TFont(InternalAddNew);
end;

procedure TFontList.Insert(index: Integer; NewObject: TFont);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TFontList.GetBoldObject(index: Integer): TFont;
begin
  result := TFont(GetElement(index));
end;

procedure TFontList.SetBoldObject(index: Integer; NewObject: TFont);
begin;
  SetElement(index, NewObject);
end;

function TFont.GetDeriveMethodForMember(Member: TBoldMember): TBoldDeriveAndResubscribe;
begin
  if (Member = M_noValues) then result := _noValues_DeriveAndSubscribe else
  if (Member = M_resultString) then result := _resultString_DeriveAndSubscribe else
  result := inherited GetDeriveMethodForMember(Member);
end;

function TFont.GetReverseDeriveMethodForMember(Member: TBoldMember): TBoldReverseDerive;
begin
  result := inherited GetReverseDeriveMethodForMember(Member);
  if not assigned(result) and (Member = M_noValues) then result := _noValues_ReverseDerive;
end;

{ TPerson }

function TPerson._Get_M_fullName: TBAString;
begin
  assert(ValidateMember('TPerson', 'fullName', 0, TBAString));
  Result := TBAString(BoldMembers[0]);
end;

function TPerson._GetfullName: String;
begin
  Result := M_fullName.AsString;
end;

procedure TPerson._SetfullName(NewValue: String);
begin
  M_fullName.AsString := NewValue;
end;

function TPerson._Get_M_firstName: TBAString;
begin
  assert(ValidateMember('TPerson', 'firstName', 1, TBAString));
  Result := TBAString(BoldMembers[1]);
end;

function TPerson._GetfirstName: String;
begin
  Result := M_firstName.AsString;
end;

procedure TPerson._SetfirstName(NewValue: String);
begin
  M_firstName.AsString := NewValue;
end;

function TPerson._Get_M_family: TBoldObjectReference;
begin
  assert(ValidateMember('TPerson', 'family', 2, TBoldObjectReference));
  Result := TBoldObjectReference(BoldMembers[2]);
end;

function TPerson._Getfamily: TFamily;
begin
  assert(not assigned(M_family.BoldObject) or (M_family.BoldObject is TFamily), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, 'family', M_family.BoldObject.ClassName, 'TFamily']));
  Result := TFamily(M_family.BoldObject);
end;

procedure TPerson._Setfamily(value: TFamily);
begin
  M_family.BoldObject := value;
end;

procedure TPersonList.Add(NewObject: TPerson);
begin
  if Assigned(NewObject) then
    AddElement(NewObject);
end;

function TPersonList.IndexOf(anObject: TPerson): Integer;
begin
  result := IndexOfElement(anObject);
end;

function TPersonList.Includes(anObject: TPerson) : Boolean;
begin
  result := IncludesElement(anObject);
end;

function TPersonList.AddNew: TPerson;
begin
  result := TPerson(InternalAddNew);
end;

procedure TPersonList.Insert(index: Integer; NewObject: TPerson);
begin
  if assigned(NewObject) then
    InsertElement(index, NewObject);
end;

function TPersonList.GetBoldObject(index: Integer): TPerson;
begin
  result := TPerson(GetElement(index));
end;

procedure TPersonList.SetBoldObject(index: Integer; NewObject: TPerson);
begin;
  SetElement(index, NewObject);
end;

function TPerson.GetDeriveMethodForMember(Member: TBoldMember): TBoldDeriveAndResubscribe;
begin
  if (Member = M_fullName) then result := _fullName_DeriveAndSubscribe else
  result := inherited GetDeriveMethodForMember(Member);
end;

function TPerson.GetReverseDeriveMethodForMember(Member: TBoldMember): TBoldReverseDerive;
begin
  result := inherited GetReverseDeriveMethodForMember(Member);
  if not assigned(result) and (Member = M_fullName) then result := _fullName_ReverseDerive;
end;

function GeneratedCodeCRC: String;
begin
  result := '1253281928';
end;

procedure InstallObjectListClasses(BoldObjectListClasses: TBoldGeneratedClassList);
begin
  BoldObjectListClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRootList);
  BoldObjectListClasses.AddObjectEntry('Family', TFamilyList);
  BoldObjectListClasses.AddObjectEntry('Font', TFontList);
  BoldObjectListClasses.AddObjectEntry('Person', TPersonList);
end;

procedure InstallBusinessClasses(BoldObjectClasses: TBoldGeneratedClassList);
begin
  BoldObjectClasses.AddObjectEntry('BusinessClassesRoot', TBusinessClassesRoot);
  BoldObjectClasses.AddObjectEntry('Family', TFamily);
  BoldObjectClasses.AddObjectEntry('Font', TFont);
  BoldObjectClasses.AddObjectEntry('Person', TPerson);
end;

var
  CodeDescriptor: TBoldGeneratedCodeDescriptor;

initialization
  CodeDescriptor := GeneratedCodes.AddGeneratedCodeDescriptorWithFunc('ReverseDeriveExampleClasses', InstallBusinessClasses, InstallObjectListClasses, GeneratedCodeCRC);
finalization
  GeneratedCodes.Remove(CodeDescriptor);
end.

 