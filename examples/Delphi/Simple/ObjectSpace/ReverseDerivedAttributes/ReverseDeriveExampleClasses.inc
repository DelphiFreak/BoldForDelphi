{**********************************************************}
   {                                                          }
   {       Bold for Delphi Stub File                          }
   {                                                          }
   {       Autogenerated file for method implementations      }
   {                                                          }
   {**********************************************************}

// 
{$INCLUDE ReverseDeriveExampleClasses_Interface.inc}

procedure TPerson._fullName_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
begin
  if assigned(family) then
    M_FullName.AsString := firstname + ' ' + family.familyName
  else
    M_fullName.AsString := firstName;

  M_FirstName.DefaultSubscribe(subscriber);
  M_family.DefaultSubscribe(subscriber, breReSubscribe);
  if assigned( family ) then
    family.M_familyName.DefaultSubscribe(subscriber);
end;

procedure TPerson._fullName_ReverseDerive(DerivedObject: TObject);
var
  newfamily: TFamily;
  aFullName, aFamilyName: String;
  p: integer;
begin
  // strip away leading and trailing spaces
  aFullName := trim(fullName);
  p := pos(' ', aFullName);
  if p <> 0 then
  begin
    // the first name is everything up to the first space
    // the family name is the rest
    firstName := copy(aFullName, 1, p - 1);
    aFamilyName := trim(copy(aFullName, p + 1, maxint));

    Newfamily := nil;

    // see if we belong to the right family already
    if assigned(family) and (family.familyName = aFamilyName) then
      NewFamily := family;

    // see if we can find an existing family
    if not assigned(newFamily) then
      NewFamily := TFamily.FindByName(BoldSystem, aFamilyName);

    // see if it is OK to rename an existing family
    if not assigned(NewFamily) and assigned(family) and (family.familyMembers.Count = 1) then
    begin
      NewFamily := family;
      family.familyName := afamilyName;
    end;

    // create a brand new family;
    if not assigned(newFamily) then
    begin
      NewFamily := TFamily.Create(BoldSystem);
      Newfamily.familyName := aFamilyName;
    end;

    if assigned(family) and (family <> NewFamily) and (family.familyMembers.count = 1) then
      family.delete;

    family := NewFamily;
  end
  else
  begin
    // if there is no familyname, the firstname is all of the new name
    FirstName := aFullName;
    // unlink from the family (the family will be deleted if he was the only member
    if assigned( family ) and (family.familyMembers.count = 1) then
      family.delete;
    family := nil;
  end;
end;

class function TFamily.FindByName(BoldSystem: TBoldSystem; familyName: string): TFamily;
var
  familyList: TFamilyList;
  i: integer;
begin
  // loop through the families until we find a nice one.
  result := nil;
  FamilyList := BoldSystem.ClassByExpressionName['Family'] as TFamilyList;
  for i := 0 to familyList.Count-1 do
    if ansiCompareStr( familyList[i].familyName, familyName ) = 0 then
    begin
      result := familyList[i];
      exit;
    end;
end;

procedure TFont.ResetAll;
begin
  Blink := False;
  Bold := False;
  UnderLine := False;
end;

procedure TFont.SubscribeToAttributes(Subscriber: TBoldSubscriber);
begin
  m_Bold.DefaultSubscribe(Subscriber);
  m_Blink.DefaultSubscribe(Subscriber);
  m_UnderLine.DefaultSubscribe(Subscriber);
end;

procedure TFont._noValues_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
begin
  SubscribeToAttributes(Subscriber);
  m_NoValues.AsBoolean := not (blink or underline or bold);
end;

procedure TFont._noValues_ReverseDerive(DerivedObject: TObject);
begin
  if NoValues then
    ResetAll;
end;

procedure TFont._resultString_DeriveAndSubscribe(DerivedObject: TObject; Subscriber: TBoldSubscriber);
var
  res: string;
begin
  res := '';
  if blink then
    res := 'blink ';
  if Bold then
    res := res + 'bold ';
  if Underline then
    res := res + 'underline ';
  m_ResultString.AsString := res;

  SubscribeToAttributes( Subscriber );
end;


 
