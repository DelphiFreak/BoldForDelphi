/*****************************************/
/*      This file is autogenerated       */
/*   Any manual changes will be LOST!    */
/*****************************************/
/* Generated 2002-01-02 16:01:15         */
/*****************************************/
/* This file should be stored in the     */
/* same directory as the form/datamodule */
/* with the corresponding model          */
/*****************************************/
/* Copyright notice:                     */
/*                                       */
/*****************************************/

#include <vcl.h>
#pragma hdrstop

#include "ProdStructClasses.hpp"

// interface uses

// interface dependancies

// attribute dependancies
#pragma link "BoldAttributes"

#pragma link "BoldDefs"
#pragma link "BoldSubscription"
#pragma link "BoldDeriver"
#pragma link "BoldElements"
#pragma link "BoldDomainElement"
#pragma link "BoldSystemRT"
#pragma link "BoldSystem"
#pragma link "BoldGeneratedCodeDictionary"

// implementation uses

// implementation dependancies

#include "BoldGeneratedCodeDictionary.hpp"

// Includefiles for methodimplementations

#include "ProdStructClasses_impl.cpp"

#define BoldMemberAssertInvalidObjectType = "Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)";

// TProdStructClassesRoot

void __fastcall TProdStructClassesRootList::Add(TProdStructClassesRoot *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TProdStructClassesRootList::IndexOf(TProdStructClassesRoot *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TProdStructClassesRootList::Includes(TProdStructClassesRoot *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TProdStructClassesRoot* __fastcall TProdStructClassesRootList::AddNew()
{
  TProdStructClassesRoot *result = dynamic_cast<TProdStructClassesRoot*>(InternalAddNew());
  return result;
}

void __fastcall TProdStructClassesRootList::Insert(int index, TProdStructClassesRoot *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TProdStructClassesRoot* __fastcall TProdStructClassesRootList::GetBoldObject(int index)
{
  TProdStructClassesRoot *result = dynamic_cast<TProdStructClassesRoot*>(GetElement(index));
  return result;
}

void __fastcall TProdStructClassesRootList::SetBoldObject(int index, TProdStructClassesRoot *NewObject)
{
  SetElement(index, NewObject);
}

// TPartOfParts

TBoldObjectReference* __fastcall TPartOfParts::_Get_M_Parts()
{
  // assert(ValidateMember("TPartOfParts", "Parts", 0, __classid(TBoldObjectReference)));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[0]);
  return result;
}

TProduct* _fastcall TPartOfParts::_GetParts()
{
  // assert(not assigned(M_Parts->BoldObject) or (M_Parts->BoldObject is TProduct), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, Parts, M_Parts->BoldObject->ClassName, __classid(TProduct)]));
  TProduct *result = dynamic_cast<TProduct*>(M_Parts->BoldObject);
  return result;
}

TBoldObjectReference* __fastcall TPartOfParts::_Get_M_PartOf()
{
  // assert(ValidateMember("TPartOfParts", "PartOf", 1, __classid(TBoldObjectReference)));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[1]);
  return result;
}

TAssembly* _fastcall TPartOfParts::_GetPartOf()
{
  // assert(not assigned(M_PartOf->BoldObject) or (M_PartOf->BoldObject is TAssembly), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, PartOf, M_PartOf->BoldObject->ClassName, __classid(TAssembly)]));
  TAssembly *result = dynamic_cast<TAssembly*>(M_PartOf->BoldObject);
  return result;
}

void __fastcall TPartOfPartsList::Add(TPartOfParts *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TPartOfPartsList::IndexOf(TPartOfParts *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TPartOfPartsList::Includes(TPartOfParts *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TPartOfParts* __fastcall TPartOfPartsList::AddNew()
{
  TPartOfParts *result = dynamic_cast<TPartOfParts*>(InternalAddNew());
  return result;
}

void __fastcall TPartOfPartsList::Insert(int index, TPartOfParts *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TPartOfParts* __fastcall TPartOfPartsList::GetBoldObject(int index)
{
  TPartOfParts *result = dynamic_cast<TPartOfParts*>(GetElement(index));
  return result;
}

void __fastcall TPartOfPartsList::SetBoldObject(int index, TPartOfParts *NewObject)
{
  SetElement(index, NewObject);
}

// TProduct

TBAString* __fastcall TProduct::_Get_M_Name()
{
  // assert(ValidateMember("TProduct", "Name", 0, __classid(TBAString)));
  TBAString *result = dynamic_cast<TBAString*>(BoldMembers[0]);
  return result;
};

String __fastcall TProduct::_GetName()
{
  String result = M_Name->AsString;
  return result;
}

void __fastcall TProduct::_SetName(String NewValue)
{
  M_Name->AsString = NewValue;
}

TBACurrency* __fastcall TProduct::_Get_M_Price()
{
  // assert(ValidateMember("TProduct", "Price", 1, __classid(TBACurrency)));
  TBACurrency *result = dynamic_cast<TBACurrency*>(BoldMembers[1]);
  return result;
};

Currency __fastcall TProduct::_GetPrice()
{
  Currency result = M_Price->AsCurrency;
  return result;
}

void __fastcall TProduct::_SetPrice(Currency NewValue)
{
  M_Price->AsCurrency = NewValue;
}

TBACurrency* __fastcall TProduct::_Get_M_TotalCost()
{
  // assert(ValidateMember("TProduct", "TotalCost", 2, __classid(TBACurrency)));
  TBACurrency *result = dynamic_cast<TBACurrency*>(BoldMembers[2]);
  return result;
};

Currency __fastcall TProduct::_GetTotalCost()
{
  Currency result = M_TotalCost->AsCurrency;
  return result;
}

TAssemblyList* __fastcall TProduct::_GetPartOf()
{
  // assert(ValidateMember("TProduct", "PartOf", 3, __classid(TAssemblyList)));
  TAssemblyList *result = dynamic_cast<TAssemblyList*>(BoldMembers[3]);
  return result;
}

TPartOfPartsList* __fastcall TProduct::_GetPartOfPartOfParts()
{
  // assert(ValidateMember("TProduct", "PartOfPartOfParts", 4, __classid(TPartOfPartsList)));
  TPartOfPartsList *result = dynamic_cast<TPartOfPartsList*>(BoldMembers[4]);
  return result;
}

void __fastcall TProductList::Add(TProduct *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TProductList::IndexOf(TProduct *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TProductList::Includes(TProduct *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TProduct* __fastcall TProductList::AddNew()
{
  TProduct *result = dynamic_cast<TProduct*>(InternalAddNew());
  return result;
}

void __fastcall TProductList::Insert(int index, TProduct *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TProduct* __fastcall TProductList::GetBoldObject(int index)
{
  TProduct *result = dynamic_cast<TProduct*>(GetElement(index));
  return result;
}

void __fastcall TProductList::SetBoldObject(int index, TProduct *NewObject)
{
  SetElement(index, NewObject);
}

TBoldDeriveAndResubscribe __fastcall TProduct::GetDeriveMethodForMember(TBoldMember *Member)
{
  TBoldDeriveAndResubscribe result = NULL;
  if ((result == NULL) && (Member == M_TotalCost)) {result = &_TotalCost_DeriveAndSubscribe;}
  if (result == NULL) {result = TProdStructClassesRoot::GetDeriveMethodForMember(Member);}
  return result;
}

TBoldReverseDerive __fastcall TProduct::GetReverseDeriveMethodForMember(TBoldMember *Member)
{
  TBoldReverseDerive result = NULL;
  if (result == NULL) {result = TProdStructClassesRoot::GetReverseDeriveMethodForMember(Member);}
  return result;
}

// TAssembly

TBACurrency* __fastcall TAssembly::_Get_M_AssemblyCost()
{
  // assert(ValidateMember("TAssembly", "AssemblyCost", 5, __classid(TBACurrency)));
  TBACurrency *result = dynamic_cast<TBACurrency*>(BoldMembers[5]);
  return result;
};

Currency __fastcall TAssembly::_GetAssemblyCost()
{
  Currency result = M_AssemblyCost->AsCurrency;
  return result;
}

void __fastcall TAssembly::_SetAssemblyCost(Currency NewValue)
{
  M_AssemblyCost->AsCurrency = NewValue;
}

TProductList* __fastcall TAssembly::_GetParts()
{
  // assert(ValidateMember("TAssembly", "Parts", 6, __classid(TProductList)));
  TProductList *result = dynamic_cast<TProductList*>(BoldMembers[6]);
  return result;
}

TPartOfPartsList* __fastcall TAssembly::_GetPartsPartOfParts()
{
  // assert(ValidateMember("TAssembly", "PartsPartOfParts", 7, __classid(TPartOfPartsList)));
  TPartOfPartsList *result = dynamic_cast<TPartOfPartsList*>(BoldMembers[7]);
  return result;
}

void __fastcall TAssemblyList::Add(TAssembly *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TAssemblyList::IndexOf(TAssembly *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TAssemblyList::Includes(TAssembly *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TAssembly* __fastcall TAssemblyList::AddNew()
{
  TAssembly *result = dynamic_cast<TAssembly*>(InternalAddNew());
  return result;
}

void __fastcall TAssemblyList::Insert(int index, TAssembly *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TAssembly* __fastcall TAssemblyList::GetBoldObject(int index)
{
  TAssembly *result = dynamic_cast<TAssembly*>(GetElement(index));
  return result;
}

void __fastcall TAssemblyList::SetBoldObject(int index, TAssembly *NewObject)
{
  SetElement(index, NewObject);
}

// TSimple_Product

TBACurrency* __fastcall TSimple_Product::_Get_M_ProductionCost()
{
  // assert(ValidateMember("TSimple_Product", "ProductionCost", 5, __classid(TBACurrency)));
  TBACurrency *result = dynamic_cast<TBACurrency*>(BoldMembers[5]);
  return result;
};

Currency __fastcall TSimple_Product::_GetProductionCost()
{
  Currency result = M_ProductionCost->AsCurrency;
  return result;
}

void __fastcall TSimple_Product::_SetProductionCost(Currency NewValue)
{
  M_ProductionCost->AsCurrency = NewValue;
}

void __fastcall TSimple_ProductList::Add(TSimple_Product *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TSimple_ProductList::IndexOf(TSimple_Product *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TSimple_ProductList::Includes(TSimple_Product *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TSimple_Product* __fastcall TSimple_ProductList::AddNew()
{
  TSimple_Product *result = dynamic_cast<TSimple_Product*>(InternalAddNew());
  return result;
}

void __fastcall TSimple_ProductList::Insert(int index, TSimple_Product *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TSimple_Product* __fastcall TSimple_ProductList::GetBoldObject(int index)
{
  TSimple_Product *result = dynamic_cast<TSimple_Product*>(GetElement(index));
  return result;
}

void __fastcall TSimple_ProductList::SetBoldObject(int index, TSimple_Product *NewObject)
{
  SetElement(index, NewObject);
}

char *GeneratedCodeCRC()
{
  return "432794881";
}

void __fastcall InstallObjectListClasses(TBoldGeneratedClassList *BoldObjectListClasses)
{
  BoldObjectListClasses->AddObjectEntry("ProdStructClassesRoot", __classid(TProdStructClassesRootList));
  BoldObjectListClasses->AddObjectEntry("PartOfParts", __classid(TPartOfPartsList));
  BoldObjectListClasses->AddObjectEntry("Product", __classid(TProductList));
  BoldObjectListClasses->AddObjectEntry("Assembly", __classid(TAssemblyList));
  BoldObjectListClasses->AddObjectEntry("Simple_Product", __classid(TSimple_ProductList));
}

void __fastcall InstallBusinessClasses(TBoldGeneratedClassList *BoldObjectClasses)
{
  BoldObjectClasses->AddObjectEntry("ProdStructClassesRoot", __classid(TProdStructClassesRoot));
  BoldObjectClasses->AddObjectEntry("PartOfParts", __classid(TPartOfParts));
  BoldObjectClasses->AddObjectEntry("Product", __classid(TProduct));
  BoldObjectClasses->AddObjectEntry("Assembly", __classid(TAssembly));
  BoldObjectClasses->AddObjectEntry("Simple_Product", __classid(TSimple_Product));
}

// the codedestricptor is initialized automatically

TBoldGeneratedCodeDescriptor *CodeDescriptor = GeneratedCodes()->AddGeneratedCodeDescriptorWithFunc("ProdStructClasses", &InstallBusinessClasses, &InstallObjectListClasses, GeneratedCodeCRC());

// but should be unloaded manually when it is not needed anymore

void unregisterCode()
{
  if (CodeDescriptor != NULL)
  {
    GeneratedCodes()->Remove(CodeDescriptor);
  }
}

