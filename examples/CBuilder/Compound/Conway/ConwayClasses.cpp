/*****************************************/
/*      This file is autogenerated       */
/*   Any manual changes will be LOST!    */
/*****************************************/
/* Generated 2001-12-03 17:20:18         */                      
/*****************************************/
/* This file should be stored in the     */
/* same directory as the form/datamodule */
/* with the corresponding model          */
/*****************************************/
/* Copyright notice:                     */
/*                                       */
/*****************************************/

#include <vcl.h>
#pragma hdrstop

#include "ConwayClasses.hpp"

// interface uses
#pragma link "Windows"

// interface dependancies

// attribute dependancies
#pragma link "BoldAttributes"

#pragma link "BoldDefs"
#pragma link "BoldSubscription"
#pragma link "BoldDeriver"
#pragma link "BoldElements"
#pragma link "BoldDomainElement"
#pragma link "BoldSystemRT"
#pragma link "BoldSystem"
#pragma link "BoldGeneratedCodeDictionary"

// implementation uses
#include "BoldReferenceHandle.hpp"
#pragma link "BoldReferenceHandle"
#include "BoldCheckBox.hpp"
#pragma link "BoldCheckBox"
#include "Dialogs.hpp"
#pragma link "Dialogs"
#include "Forms.hpp"
#pragma link "Forms"
#include "BoldQueue.hpp"
#pragma link "BoldQueue"

// implementation dependancies

#include "BoldGeneratedCodeDictionary.hpp"

// Includefiles for methodimplementations

#include "ConwayClasses_impl.cpp"

#define BoldMemberAssertInvalidObjectType = "Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)";

// TBusinessClassesRoot

void __fastcall TBusinessClassesRootList::Add(TBusinessClassesRoot *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TBusinessClassesRootList::IndexOf(TBusinessClassesRoot *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TBusinessClassesRootList::Includes(TBusinessClassesRoot *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TBusinessClassesRoot* __fastcall TBusinessClassesRootList::AddNew()
{
  TBusinessClassesRoot *result = dynamic_cast<TBusinessClassesRoot*>(InternalAddNew());
  return result;
}

void __fastcall TBusinessClassesRootList::Insert(int index, TBusinessClassesRoot *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TBusinessClassesRoot* __fastcall TBusinessClassesRootList::GetBoldObject(int index)
{
  TBusinessClassesRoot *result = dynamic_cast<TBusinessClassesRoot*>(GetElement(index));
  return result;
}

void __fastcall TBusinessClassesRootList::SetBoldObject(int index, TBusinessClassesRoot *NewObject)
{
  SetElement(index, NewObject);
}

// TCell

TBABoolean* __fastcall TCell::_Get_M_Active()
{
  // assert(ValidateMember("TCell", "Active", 0, TBABoolean));
  TBABoolean *result = dynamic_cast<TBABoolean*>(BoldMembers[0]);
  return result;
};

Boolean __fastcall TCell::_GetActive()
{
  Boolean result = M_Active->AsBoolean;
  return result;
}

void __fastcall TCell::_SetActive(Boolean NewValue)
{
  M_Active->AsBoolean = NewValue;
}

TBAInteger* __fastcall TCell::_Get_M_neighbours()
{
  // assert(ValidateMember("TCell", "neighbours", 1, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[1]);
  return result;
};

Integer __fastcall TCell::_Getneighbours()
{
  Integer result = M_neighbours->AsInteger;
  return result;
}

TBAInteger* __fastcall TCell::_Get_M_x()
{
  // assert(ValidateMember("TCell", "x", 2, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[2]);
  return result;
};

Integer __fastcall TCell::_Getx()
{
  Integer result = M_x->AsInteger;
  return result;
}

void __fastcall TCell::_Setx(Integer NewValue)
{
  M_x->AsInteger = NewValue;
}

TBAInteger* __fastcall TCell::_Get_M_y()
{
  // assert(ValidateMember("TCell", "y", 3, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[3]);
  return result;
};

Integer __fastcall TCell::_Gety()
{
  Integer result = M_y->AsInteger;
  return result;
}

void __fastcall TCell::_Sety(Integer NewValue)
{
  M_y->AsInteger = NewValue;
}

TBAInteger* __fastcall TCell::_Get_M_ActiveCount()
{
  // assert(ValidateMember("TCell", "ActiveCount", 4, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[4]);
  return result;
};

Integer __fastcall TCell::_GetActiveCount()
{
  Integer result = M_ActiveCount->AsInteger;
  return result;
}

TBoldObjectReference* __fastcall TCell::_Get_M_Game()
{
  // assert(ValidateMember("TCell", "Game", 5, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[5]);
  return result;
}

TGame* _fastcall TCell::_GetGame()
{
  // assert(not assigned(M_Game->BoldObject) or (M_Game->BoldObject is TGame), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, Game, M_Game->BoldObject->ClassName, TGame]));
  TGame *result = dynamic_cast<TGame*>(M_Game->BoldObject);
  return result;
}

void __fastcall TCell::_SetGame(TGame *value)
{
  M_Game->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cLeft()
{
  // assert(ValidateMember("TCell", "cLeft", 6, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[6]);
  return result;
}

TCell* _fastcall TCell::_GetcLeft()
{
  // assert(not assigned(M_cLeft->BoldObject) or (M_cLeft->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cLeft, M_cLeft->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cLeft->BoldObject);
  return result;
}

void __fastcall TCell::_SetcLeft(TCell *value)
{
  M_cLeft->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cRight()
{
  // assert(ValidateMember("TCell", "cRight", 7, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[7]);
  return result;
}

TCell* _fastcall TCell::_GetcRight()
{
  // assert(not assigned(M_cRight->BoldObject) or (M_cRight->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cRight, M_cRight->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cRight->BoldObject);
  return result;
}

void __fastcall TCell::_SetcRight(TCell *value)
{
  M_cRight->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cDown()
{
  // assert(ValidateMember("TCell", "cDown", 8, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[8]);
  return result;
}

TCell* _fastcall TCell::_GetcDown()
{
  // assert(not assigned(M_cDown->BoldObject) or (M_cDown->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cDown, M_cDown->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cDown->BoldObject);
  return result;
}

void __fastcall TCell::_SetcDown(TCell *value)
{
  M_cDown->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cUp()
{
  // assert(ValidateMember("TCell", "cUp", 9, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[9]);
  return result;
}

TCell* _fastcall TCell::_GetcUp()
{
  // assert(not assigned(M_cUp->BoldObject) or (M_cUp->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cUp, M_cUp->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cUp->BoldObject);
  return result;
}

void __fastcall TCell::_SetcUp(TCell *value)
{
  M_cUp->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cDownLeft()
{
  // assert(ValidateMember("TCell", "cDownLeft", 10, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[10]);
  return result;
}

TCell* _fastcall TCell::_GetcDownLeft()
{
  // assert(not assigned(M_cDownLeft->BoldObject) or (M_cDownLeft->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cDownLeft, M_cDownLeft->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cDownLeft->BoldObject);
  return result;
}

void __fastcall TCell::_SetcDownLeft(TCell *value)
{
  M_cDownLeft->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cUpRight()
{
  // assert(ValidateMember("TCell", "cUpRight", 11, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[11]);
  return result;
}

TCell* _fastcall TCell::_GetcUpRight()
{
  // assert(not assigned(M_cUpRight->BoldObject) or (M_cUpRight->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cUpRight, M_cUpRight->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cUpRight->BoldObject);
  return result;
}

void __fastcall TCell::_SetcUpRight(TCell *value)
{
  M_cUpRight->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cDownRight()
{
  // assert(ValidateMember("TCell", "cDownRight", 12, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[12]);
  return result;
}

TCell* _fastcall TCell::_GetcDownRight()
{
  // assert(not assigned(M_cDownRight->BoldObject) or (M_cDownRight->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cDownRight, M_cDownRight->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cDownRight->BoldObject);
  return result;
}

void __fastcall TCell::_SetcDownRight(TCell *value)
{
  M_cDownRight->BoldObject = value;
}

TBoldObjectReference* __fastcall TCell::_Get_M_cUpLeft()
{
  // assert(ValidateMember("TCell", "cUpLeft", 13, TBoldObjectReference));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[13]);
  return result;
}

TCell* _fastcall TCell::_GetcUpLeft()
{
  // assert(not assigned(M_cUpLeft->BoldObject) or (M_cUpLeft->BoldObject is TCell), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, cUpLeft, M_cUpLeft->BoldObject->ClassName, TCell]));
  TCell *result = dynamic_cast<TCell*>(M_cUpLeft->BoldObject);
  return result;
}

void __fastcall TCell::_SetcUpLeft(TCell *value)
{
  M_cUpLeft->BoldObject = value;
}

void __fastcall TCellList::Add(TCell *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TCellList::IndexOf(TCell *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TCellList::Includes(TCell *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TCell* __fastcall TCellList::AddNew()
{
  TCell *result = dynamic_cast<TCell*>(InternalAddNew());
  return result;
}

void __fastcall TCellList::Insert(int index, TCell *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TCell* __fastcall TCellList::GetBoldObject(int index)
{
  TCell *result = dynamic_cast<TCell*>(GetElement(index));
  return result;
}

void __fastcall TCellList::SetBoldObject(int index, TCell *NewObject)
{
  SetElement(index, NewObject);
}

// TGame

TBAInteger* __fastcall TGame::_Get_M_TimerTime()
{
  // assert(ValidateMember("TGame", "TimerTime", 0, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[0]);
  return result;
};

Integer __fastcall TGame::_GetTimerTime()
{
  Integer result = M_TimerTime->AsInteger;
  return result;
}

void __fastcall TGame::_SetTimerTime(Integer NewValue)
{
  M_TimerTime->AsInteger = NewValue;
}

TBAInteger* __fastcall TGame::_Get_M_Generations()
{
  // assert(ValidateMember("TGame", "Generations", 1, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[1]);
  return result;
};

Integer __fastcall TGame::_GetGenerations()
{
  Integer result = M_Generations->AsInteger;
  return result;
}

void __fastcall TGame::_SetGenerations(Integer NewValue)
{
  M_Generations->AsInteger = NewValue;
}

TBABlob* __fastcall TGame::_Get_M_board()
{
  // assert(ValidateMember("TGame", "board", 2, TBABlob));
  TBABlob *result = dynamic_cast<TBABlob*>(BoldMembers[2]);
  return result;
};

String __fastcall TGame::_Getboard()
{
  String result = M_board->AsString;
  return result;
}

void __fastcall TGame::_Setboard(String NewValue)
{
  M_board->AsString = NewValue;
}

TBAInteger* __fastcall TGame::_Get_M_xMax()
{
  // assert(ValidateMember("TGame", "xMax", 3, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[3]);
  return result;
};

Integer __fastcall TGame::_GetxMax()
{
  Integer result = M_xMax->AsInteger;
  return result;
}

void __fastcall TGame::_SetxMax(Integer NewValue)
{
  M_xMax->AsInteger = NewValue;
}

TBAInteger* __fastcall TGame::_Get_M_xMin()
{
  // assert(ValidateMember("TGame", "xMin", 4, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[4]);
  return result;
};

Integer __fastcall TGame::_GetxMin()
{
  Integer result = M_xMin->AsInteger;
  return result;
}

void __fastcall TGame::_SetxMin(Integer NewValue)
{
  M_xMin->AsInteger = NewValue;
}

TBAInteger* __fastcall TGame::_Get_M_yMax()
{
  // assert(ValidateMember("TGame", "yMax", 5, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[5]);
  return result;
};

Integer __fastcall TGame::_GetyMax()
{
  Integer result = M_yMax->AsInteger;
  return result;
}

void __fastcall TGame::_SetyMax(Integer NewValue)
{
  M_yMax->AsInteger = NewValue;
}

TBAInteger* __fastcall TGame::_Get_M_yMin()
{
  // assert(ValidateMember("TGame", "yMin", 6, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[6]);
  return result;
};

Integer __fastcall TGame::_GetyMin()
{
  Integer result = M_yMin->AsInteger;
  return result;
}

void __fastcall TGame::_SetyMin(Integer NewValue)
{
  M_yMin->AsInteger = NewValue;
}

TBAInteger* __fastcall TGame::_Get_M_xSize()
{
  // assert(ValidateMember("TGame", "xSize", 7, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[7]);
  return result;
};

Integer __fastcall TGame::_GetxSize()
{
  Integer result = M_xSize->AsInteger;
  return result;
}

TBAInteger* __fastcall TGame::_Get_M_FontSize()
{
  // assert(ValidateMember("TGame", "FontSize", 8, TBAInteger));
  TBAInteger *result = dynamic_cast<TBAInteger*>(BoldMembers[8]);
  return result;
};

Integer __fastcall TGame::_GetFontSize()
{
  Integer result = M_FontSize->AsInteger;
  return result;
}

void __fastcall TGame::_SetFontSize(Integer NewValue)
{
  M_FontSize->AsInteger = NewValue;
}

TBABoolean* __fastcall TGame::_Get_M_collecting()
{
  // assert(ValidateMember("TGame", "collecting", 9, TBABoolean));
  TBABoolean *result = dynamic_cast<TBABoolean*>(BoldMembers[9]);
  return result;
};

Boolean __fastcall TGame::_Getcollecting()
{
  Boolean result = M_collecting->AsBoolean;
  return result;
}

void __fastcall TGame::_Setcollecting(Boolean NewValue)
{
  M_collecting->AsBoolean = NewValue;
}

TCellList* __fastcall TGame::_GetCell()
{
  // assert(ValidateMember("TGame", "Cell", 10, TCellList));
  // ISJE TCellList *result = dynamic_cast<TCellList*>(BoldMembers[10]);
  TCellList *result = (TCellList*)(BoldMembers[10]);
  return result;
}

TCellList* __fastcall TGame::_Getcoord()
{
  // assert(ValidateMember("TGame", "coord", 11, TCellList));
  //TCellList *result = dynamic_cast<TCellList*>(BoldMembers[11]);
  TCellList *result = (TCellList*)(BoldMembers[11]);
  return result;
}

TCell* __fastcall TGame::_Get_Q_coord(Integer x, Integer y)
{
  TBoldObject* TempResult;
  TBoldMemberList* TempList = new TBoldMemberList;
  TempList->CloneMembers = false;
  TBAInteger* Q_x = new TBAInteger;
  TBAInteger* Q_y = new TBAInteger;
  try
  {
    Q_x->AsInteger = x;
    TempList->Add(Q_x);
    Q_y->AsInteger = y;
    TempList->Add(Q_y);
    TempResult = M_coord->GetByIndex(TempList);
    // assert(not assigned(TempResult) or (TempResult is TCell), "Illegal object in multilink");
  }
  __finally
  {
    delete TempList;
    delete Q_x;
    delete Q_y;
  }
  return dynamic_cast<TCell*>(TempResult);
}

void __fastcall TGameList::Add(TGame *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TGameList::IndexOf(TGame *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TGameList::Includes(TGame *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TGame* __fastcall TGameList::AddNew()
{
  TGame *result = dynamic_cast<TGame*>(InternalAddNew());
  return result;
}

void __fastcall TGameList::Insert(int index, TGame *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TGame* __fastcall TGameList::GetBoldObject(int index)
{
  TGame *result = dynamic_cast<TGame*>(GetElement(index));
  return result;
}

void __fastcall TGameList::SetBoldObject(int index, TGame *NewObject)
{
  SetElement(index, NewObject);
}

TBoldDeriveAndResubscribe __fastcall TGame::GetDeriveMethodForMember(TBoldMember *Member)
{
  TBoldDeriveAndResubscribe result = NULL;
  if ((result == NULL) && (Member == M_board)) {result = &_board_DeriveAndSubscribe;}
  if (result == NULL) {result = TBusinessClassesRoot::GetDeriveMethodForMember(Member);}
  return result;
}

TBoldReverseDerive __fastcall TGame::GetReverseDeriveMethodForMember(TBoldMember *Member)
{
  TBoldReverseDerive result = NULL;
  if ((result == NULL) && (Member == M_board)) {result = &_board_ReverseDerive;}
  if (result == NULL) {result = TBusinessClassesRoot::GetReverseDeriveMethodForMember(Member);}
  return result;
}

char *GeneratedCodeCRC()
{
  return "2017684102";
}

void __fastcall InstallObjectListClasses(TBoldGeneratedClassList *BoldObjectListClasses)
{
  BoldObjectListClasses->AddObjectEntry("BusinessClassesRootList", __classid(TBusinessClassesRootList));
  BoldObjectListClasses->AddObjectEntry("CellList", __classid(TCellList));
  BoldObjectListClasses->AddObjectEntry("GameList", __classid(TGameList));
}

void __fastcall InstallBusinessClasses(TBoldGeneratedClassList *BoldObjectClasses)
{
  BoldObjectClasses->AddObjectEntry("BusinessClassesRoot", __classid(TBusinessClassesRoot));
  BoldObjectClasses->AddObjectEntry("Cell", __classid(TCell));
  BoldObjectClasses->AddObjectEntry("Game", __classid(TGame));
}

// the codedestricptor is initialized automatically

TBoldGeneratedCodeDescriptor *CodeDescriptor = GeneratedCodes()->AddGeneratedCodeDescriptorWithFunc("ConwayClasses", &InstallBusinessClasses, &InstallObjectListClasses, GeneratedCodeCRC());

// but should be unloaded manually when it is not needed anymore

void unregisterCode()
{
  if (CodeDescriptor != NULL)
  {
    GeneratedCodes()->Remove(CodeDescriptor);
  }
}

