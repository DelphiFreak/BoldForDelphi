/*****************************************/
/*      This file is autogenerated       */
/*   Any manual changes will be LOST!    */
/*****************************************/
/* Generated 2002-01-15 14:39:18         */
/*****************************************/
/* This file should be stored in the     */
/* same directory as the form/datamodule */
/* with the corresponding model          */
/*****************************************/
/* Copyright notice:                     */
/*                                       */
/*****************************************/

#include <vcl.h>
#pragma hdrstop

#include "ReverseDeriveExampleClasses.hpp"

// interface uses

// interface dependancies

// attribute dependancies
#pragma link "BoldAttributes"

#pragma link "BoldDefs"
#pragma link "BoldSubscription"
#pragma link "BoldDeriver"
#pragma link "BoldElements"
#pragma link "BoldDomainElement"
#pragma link "BoldSystemRT"
#pragma link "BoldSystem"
#pragma link "BoldGeneratedCodeDictionary"

// implementation uses

// implementation dependancies

#include "BoldGeneratedCodeDictionary.hpp"

// Includefiles for methodimplementations

#include "ReverseDeriveExampleClasses_impl.cpp"

#define BoldMemberAssertInvalidObjectType = "Object of singlelink (%s.%s) is of wrong type (is %s, should be %s)";

// TBusinessClassesRoot

void __fastcall TBusinessClassesRootList::Add(TBusinessClassesRoot *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TBusinessClassesRootList::IndexOf(TBusinessClassesRoot *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TBusinessClassesRootList::Includes(TBusinessClassesRoot *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TBusinessClassesRoot* __fastcall TBusinessClassesRootList::AddNew()
{
  TBusinessClassesRoot *result = dynamic_cast<TBusinessClassesRoot*>(InternalAddNew());
  return result;
}

void __fastcall TBusinessClassesRootList::Insert(int index, TBusinessClassesRoot *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TBusinessClassesRoot* __fastcall TBusinessClassesRootList::GetBoldObject(int index)
{
  TBusinessClassesRoot *result = dynamic_cast<TBusinessClassesRoot*>(GetElement(index));
  return result;
}

void __fastcall TBusinessClassesRootList::SetBoldObject(int index, TBusinessClassesRoot *NewObject)
{
  SetElement(index, NewObject);
}

// TFamily

TBAString* __fastcall TFamily::_Get_M_familyName()
{
  // assert(ValidateMember("TFamily", "familyName", 0, __classid(TBAString)));
  TBAString *result = dynamic_cast<TBAString*>(BoldMembers[0]);
  return result;
};

String __fastcall TFamily::_GetfamilyName()
{
  String result = M_familyName->AsString;
  return result;
}

void __fastcall TFamily::_SetfamilyName(String NewValue)
{
  M_familyName->AsString = NewValue;
}

TPersonList* __fastcall TFamily::_GetfamilyMembers()
{
  // assert(ValidateMember("TFamily", "familyMembers", 1, __classid(TPersonList)));
  TPersonList *result = dynamic_cast<TPersonList*>(BoldMembers[1]);
  return result;
}

void __fastcall TFamilyList::Add(TFamily *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TFamilyList::IndexOf(TFamily *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TFamilyList::Includes(TFamily *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TFamily* __fastcall TFamilyList::AddNew()
{
  TFamily *result = dynamic_cast<TFamily*>(InternalAddNew());
  return result;
}

void __fastcall TFamilyList::Insert(int index, TFamily *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TFamily* __fastcall TFamilyList::GetBoldObject(int index)
{
  TFamily *result = dynamic_cast<TFamily*>(GetElement(index));
  return result;
}

void __fastcall TFamilyList::SetBoldObject(int index, TFamily *NewObject)
{
  SetElement(index, NewObject);
}

// TMyFont

TBABoolean* __fastcall TMyFont::_Get_M_blink()
{
  // assert(ValidateMember("TMyFont", "blink", 0, __classid(TBABoolean)));
  TBABoolean *result = dynamic_cast<TBABoolean*>(BoldMembers[0]);
  return result;
};

Boolean __fastcall TMyFont::_Getblink()
{
  Boolean result = M_blink->AsBoolean;
  return result;
}

void __fastcall TMyFont::_Setblink(Boolean NewValue)
{
  M_blink->AsBoolean = NewValue;
}

TBABoolean* __fastcall TMyFont::_Get_M_bold()
{
  // assert(ValidateMember("TMyFont", "bold", 1, __classid(TBABoolean)));
  TBABoolean *result = dynamic_cast<TBABoolean*>(BoldMembers[1]);
  return result;
};

Boolean __fastcall TMyFont::_Getbold()
{
  Boolean result = M_bold->AsBoolean;
  return result;
}

void __fastcall TMyFont::_Setbold(Boolean NewValue)
{
  M_bold->AsBoolean = NewValue;
}

TBABoolean* __fastcall TMyFont::_Get_M_noValues()
{
  // assert(ValidateMember("TMyFont", "noValues", 2, __classid(TBABoolean)));
  TBABoolean *result = dynamic_cast<TBABoolean*>(BoldMembers[2]);
  return result;
};

Boolean __fastcall TMyFont::_GetnoValues()
{
  Boolean result = M_noValues->AsBoolean;
  return result;
}

void __fastcall TMyFont::_SetnoValues(Boolean NewValue)
{
  M_noValues->AsBoolean = NewValue;
}

TBABoolean* __fastcall TMyFont::_Get_M_underline()
{
  // assert(ValidateMember("TMyFont", "underline", 3, __classid(TBABoolean)));
  TBABoolean *result = dynamic_cast<TBABoolean*>(BoldMembers[3]);
  return result;
};

Boolean __fastcall TMyFont::_Getunderline()
{
  Boolean result = M_underline->AsBoolean;
  return result;
}

void __fastcall TMyFont::_Setunderline(Boolean NewValue)
{
  M_underline->AsBoolean = NewValue;
}

TBAString* __fastcall TMyFont::_Get_M_resultString()
{
  // assert(ValidateMember("TMyFont", "resultString", 4, __classid(TBAString)));
  TBAString *result = dynamic_cast<TBAString*>(BoldMembers[4]);
  return result;
};

String __fastcall TMyFont::_GetresultString()
{
  String result = M_resultString->AsString;
  return result;
}

TBAString* __fastcall TMyFont::_Get_M_name()
{
  // assert(ValidateMember("TMyFont", "name", 5, __classid(TBAString)));
  TBAString *result = dynamic_cast<TBAString*>(BoldMembers[5]);
  return result;
};

String __fastcall TMyFont::_Getname()
{
  String result = M_name->AsString;
  return result;
}

void __fastcall TMyFont::_Setname(String NewValue)
{
  M_name->AsString = NewValue;
}

void __fastcall TMyFontList::Add(TMyFont *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TMyFontList::IndexOf(TMyFont *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TMyFontList::Includes(TMyFont *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TMyFont* __fastcall TMyFontList::AddNew()
{
  TMyFont *result = dynamic_cast<TMyFont*>(InternalAddNew());
  return result;
}

void __fastcall TMyFontList::Insert(int index, TMyFont *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TMyFont* __fastcall TMyFontList::GetBoldObject(int index)
{
  TMyFont *result = dynamic_cast<TMyFont*>(GetElement(index));
  return result;
}

void __fastcall TMyFontList::SetBoldObject(int index, TMyFont *NewObject)
{
  SetElement(index, NewObject);
}

TBoldDeriveAndResubscribe __fastcall TMyFont::GetDeriveMethodForMember(TBoldMember *Member)
{
  TBoldDeriveAndResubscribe result = NULL;
  if ((result == NULL) && (Member == M_noValues)) {result = &_noValues_DeriveAndSubscribe;}
  if ((result == NULL) && (Member == M_resultString)) {result = &_resultString_DeriveAndSubscribe;}
  if (result == NULL) {result = TBusinessClassesRoot::GetDeriveMethodForMember(Member);}
  return result;
}

TBoldReverseDerive __fastcall TMyFont::GetReverseDeriveMethodForMember(TBoldMember *Member)
{
  TBoldReverseDerive result = NULL;
  if ((result == NULL) && (Member == M_noValues)) {result = &_noValues_ReverseDerive;}
  if (result == NULL) {result = TBusinessClassesRoot::GetReverseDeriveMethodForMember(Member);}
  return result;
}

// TPerson

TBAString* __fastcall TPerson::_Get_M_fullName()
{
  // assert(ValidateMember("TPerson", "fullName", 0, __classid(TBAString)));
  TBAString *result = dynamic_cast<TBAString*>(BoldMembers[0]);
  return result;
};

String __fastcall TPerson::_GetfullName()
{
  String result = M_fullName->AsString;
  return result;
}

void __fastcall TPerson::_SetfullName(String NewValue)
{
  M_fullName->AsString = NewValue;
}

TBAString* __fastcall TPerson::_Get_M_firstName()
{
  // assert(ValidateMember("TPerson", "firstName", 1, __classid(TBAString)));
  TBAString *result = dynamic_cast<TBAString*>(BoldMembers[1]);
  return result;
};

String __fastcall TPerson::_GetfirstName()
{
  String result = M_firstName->AsString;
  return result;
}

void __fastcall TPerson::_SetfirstName(String NewValue)
{
  M_firstName->AsString = NewValue;
}

TBoldObjectReference* __fastcall TPerson::_Get_M_family()
{
  // assert(ValidateMember("TPerson", "family", 2, __classid(TBoldObjectReference)));
  TBoldObjectReference *result = dynamic_cast<TBoldObjectReference*>(BoldMembers[2]);
  return result;
}

TFamily* _fastcall TPerson::_Getfamily()
{
  // assert(not assigned(M_family->BoldObject) or (M_family->BoldObject is TFamily), SysUtils.format(BoldMemberAssertInvalidObjectType, [ClassName, family, M_family->BoldObject->ClassName, __classid(TFamily)]));
  TFamily *result = dynamic_cast<TFamily*>(M_family->BoldObject);
  return result;
}

void __fastcall TPerson::_Setfamily(TFamily *value)
{
  M_family->BoldObject = value;
}

void __fastcall TPersonList::Add(TPerson *NewObject)
{
  if (NewObject != NULL)
  {
    AddElement(NewObject);
  }
}

int __fastcall TPersonList::IndexOf(TPerson *anObject)
{
  int result = IndexOfElement(anObject);
  return result;
}

int __fastcall TPersonList::Includes(TPerson *anObject) // boolean?
{
  int result = IncludesElement(anObject);
  return result;
}

TPerson* __fastcall TPersonList::AddNew()
{
  TPerson *result = dynamic_cast<TPerson*>(InternalAddNew());
  return result;
}

void __fastcall TPersonList::Insert(int index, TPerson *NewObject)
{
  if (NewObject != NULL)
  {
    InsertElement(index, NewObject);
  }
}

TPerson* __fastcall TPersonList::GetBoldObject(int index)
{
  TPerson *result = dynamic_cast<TPerson*>(GetElement(index));
  return result;
}

void __fastcall TPersonList::SetBoldObject(int index, TPerson *NewObject)
{
  SetElement(index, NewObject);
}

TBoldDeriveAndResubscribe __fastcall TPerson::GetDeriveMethodForMember(TBoldMember *Member)
{
  TBoldDeriveAndResubscribe result = NULL;
  if ((result == NULL) && (Member == M_fullName)) {result = &_fullName_DeriveAndSubscribe;}
  if (result == NULL) {result = TBusinessClassesRoot::GetDeriveMethodForMember(Member);}
  return result;
}

TBoldReverseDerive __fastcall TPerson::GetReverseDeriveMethodForMember(TBoldMember *Member)
{
  TBoldReverseDerive result = NULL;
  if ((result == NULL) && (Member == M_fullName)) {result = &_fullName_ReverseDerive;}
  if (result == NULL) {result = TBusinessClassesRoot::GetReverseDeriveMethodForMember(Member);}
  return result;
}

char *GeneratedCodeCRC()
{
  return "1253291522";
}

void __fastcall InstallObjectListClasses(TBoldGeneratedClassList *BoldObjectListClasses)
{
  BoldObjectListClasses->AddObjectEntry("BusinessClassesRoot", __classid(TBusinessClassesRootList));
  BoldObjectListClasses->AddObjectEntry("Family", __classid(TFamilyList));
  BoldObjectListClasses->AddObjectEntry("MyFont", __classid(TMyFontList));
  BoldObjectListClasses->AddObjectEntry("Person", __classid(TPersonList));
}

void __fastcall InstallBusinessClasses(TBoldGeneratedClassList *BoldObjectClasses)
{
  BoldObjectClasses->AddObjectEntry("BusinessClassesRoot", __classid(TBusinessClassesRoot));
  BoldObjectClasses->AddObjectEntry("Family", __classid(TFamily));
  BoldObjectClasses->AddObjectEntry("MyFont", __classid(TMyFont));
  BoldObjectClasses->AddObjectEntry("Person", __classid(TPerson));
}

// the codedestricptor is initialized automatically

TBoldGeneratedCodeDescriptor *CodeDescriptor = GeneratedCodes()->AddGeneratedCodeDescriptorWithFunc("ReverseDeriveExampleClasses", &InstallBusinessClasses, &InstallObjectListClasses, GeneratedCodeCRC());

// but should be unloaded manually when it is not needed anymore

void unregisterCode()
{
  if (CodeDescriptor != NULL)
  {
    GeneratedCodes()->Remove(CodeDescriptor);
  }
}

