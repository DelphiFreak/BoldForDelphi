//**********************************************************//
//                                                          //
//       Bold for Delphi Stub File                          //
//                                                          //
//       Autogenerated file for method implementations      //
//                                                          //
//**********************************************************//

//
#include "ReverseDeriveExampleClasses.hpp"

/* FindByName is not used i CBuilder-example. */
TFamily* __fastcall TFamily::FindByName(TBoldSystem BoldSystem, AnsiString familyName)
{
  TFamilyList *familyList;
  Integer i;
  TFamily *fam;

  // loop through the families until we find a nice one.
  familyList = (TFamilyList*)(BoldSystem.ClassByExpressionName["Family"]);
  for (i = 0; i < familyList->Count; i++)
  {
    if (AnsiCompareStr( familyList->BoldObjects[i]->familyName, familyName) == 0 )
    {
      fam = familyList->BoldObjects[i];
      return fam;
    }
  }
  return NULL;
}

void __fastcall TMyFont::ResetAll(void)
{
  blink = false;
  bold = false;
  underline = false;
}

void __fastcall TMyFont::SubscribeToAttributes(TBoldSubscriber *Subscriber)
{
  M_bold->DefaultSubscribe(Subscriber, breReSubscribe);
  M_blink->DefaultSubscribe(Subscriber, breReSubscribe);
  M_underline->DefaultSubscribe(Subscriber, breReSubscribe);
}

void __fastcall TMyFont::_noValues_DeriveAndSubscribe(TObject* DerivedObject, TBoldSubscriber* Subscriber)
{
  SubscribeToAttributes(Subscriber);
  M_noValues->AsBoolean = (!(blink || underline || bold));
}

void __fastcall TMyFont::_noValues_ReverseDerive(TObject* DerivedObject)
{
  if (noValues)
    ResetAll();
}

void __fastcall TMyFont::_resultString_DeriveAndSubscribe(TObject* DerivedObject, TBoldSubscriber* Subscriber)
{
  AnsiString res;

  res = "";
  if (blink)
    res = "blink ";
  if (bold)
    res = res + "bold ";
  if (underline)
    res = res + "underline ";
  M_resultString->AsString = res;

  SubscribeToAttributes(Subscriber);
}

void __fastcall TPerson::_fullName_DeriveAndSubscribe(TObject* DerivedObject, TBoldSubscriber* Subscriber)
{
  if (family)
    M_fullName->AsString = firstName + " " + family->familyName;
  else
    M_fullName->AsString = firstName;

  M_firstName->DefaultSubscribe(Subscriber, breReSubscribe);
  M_family->DefaultSubscribe(Subscriber, breReSubscribe);
  if (family)
    family->M_familyName->DefaultSubscribe(Subscriber, breReSubscribe);
}

void __fastcall TPerson::_fullName_ReverseDerive(TObject* DerivedObject)
{
  TFamily* newFamily = NULL;
  AnsiString aFullName, aFamilyName;
  Integer p;

  // strip away leading and trailing spaces
  aFullName = Trim(fullName);
  p = aFullName.Pos(" ");
  if (p != 0)
  {
    // the first name is everything up to the first space
    // the family name is the rest
    firstName = aFullName.SubString(1, p - 1);
    aFamilyName = Trim(aFullName.SubString(p + 1, aFullName.Length()));

    // see if we belong to the right family already
    if ( (family) && (family->familyName == aFamilyName) )
      newFamily = family;

    // see if we can find an existing family
    if (!newFamily)
    {
      /* FindByName is not used i CBuilder-example. Code below is used instead. */
      //newFamily = dynamic_cast<TFamily*>(TFamily::FindByName(BoldSystem, aFamilyName));

      TFamilyList *familyList;
      Integer i;

      // loop through the families until we find a nice one.
      familyList = (TFamilyList*)(BoldSystem->ClassByExpressionName["Family"]);
      for (i = 0; i < familyList->Count; i++)
      {
        if (AnsiCompareStr( familyList->BoldObjects[i]->familyName, aFamilyName) == 0 )
        {
          newFamily = familyList->BoldObjects[i];
          break;
        }
      }
    }

    // see if it is OK to rename an existing family
    if ( (!newFamily) && (family) && (family->familyMembers->Count == 1) )
    {
      newFamily = family;
      family->familyName = aFamilyName;
    }

    // create a brand new family;
    if (!newFamily)
    {
      newFamily = new TFamily(BoldSystem);
      newFamily->familyName = aFamilyName;
    }

    if ( (family) && (family != newFamily) && (family->familyMembers->Count == 1) )
      family->Delete();

    family = newFamily;
  }
  else
  {
    // if there is no familyname, the firstname is all of the new name
    firstName = aFullName;
    // unlink from the family (the family will be deleted if he was the only member
    if ( (family ) && (family->familyMembers->Count == 1) )
      family->Delete();
    family = NULL;
  }
}
