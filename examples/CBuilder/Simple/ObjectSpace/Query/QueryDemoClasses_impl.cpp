//**********************************************************//
//                                                          //
//       Bold for Delphi Stub File                          //
//                                                          //
//       Autogenerated file for method implementations      //
//                                                          //
//**********************************************************//

//
#include "QueryDemoClasses.hpp"

Boolean __fastcall TThing::IsTransitivePartOf(TThing* aThing)
{
  return ( (aThing == this) || ( (partof) && (partof->IsTransitivePartOf(aThing)) ) );
}

Boolean __fastcall TThing::ReceiveQueryFromOwned(TObject *Originator, TBoldEvent OriginalEvent, const System::TVarRec * Args, const int Args_Size, Boldsubscription::TBoldSubscriber* Subscriber)
{
  // return TBusinessClassesRoot::ReceiveQueryFromOwned(Originator, OriginalEvent, Args, ARRAYSIZE(Args) - 1, Subscriber);

  // This function is called when someone wants to know if it can access one of this object's members.
  // Return True to allow the operation and False to disallow it.

  Boolean result = true; // Default. Allow all operations.

  if (Originator == parts)
    result = GrantQueryParts(this, OriginalEvent, Args);
  else if ( (Originator == M_partof) && (OriginalEvent == bqMaySetValue) )
    result = GrantQueryPartOf(this, Args);
  else if ( (Originator == M_Name) && (OriginalEvent == bqMaySetValue) &&
    (AnsiString(Args[0].VPChar) == "It") )  // Can we set the 'Name' attribute to this? // Disallow calling things 'It'.
  {
    result = false;
    SetBoldLastFailureReason(new TBoldFailureReason("A Thing can not be called It", NULL));
  }
  else if ( (Originator == M_Name) && (OriginalEvent == bqMayUpdate) && (Name == "") )// Can we update the 'Name' attribute? Disallow saving empty names.
  {
     result = false;
    SetBoldLastFailureReason(new TBoldFailureReason("Can not save a thing with empty name", NULL));
  }
  return result;
}

// Don't allow more than four parts
Boolean __fastcall TThing::ValidateMaxParts(TThing* aThing)
{
  Boolean result = true;
  if (aThing->parts->Count >= 4 )
  {
    result = false;
    SetBoldLastFailureReason(new TBoldFailureReason("A Thing can not have more than four parts", NULL));
  }
  return result;
}

// Don't allow an object to be part of itself
Boolean __fastcall TThing::ValidatePartOfSelf(TThing* Thing1, TThing* Thing2)
{
  Boolean result = true;
  if (Thing1->IsTransitivePartOf(Thing2))
  {
    result = false;
    SetBoldLastFailureReason(new TBoldFailureReason("A Thing can not be part of itself", NULL));
  }
  return result;
}

Boolean __fastcall TThing::GrantQueryParts(TThing* aThing, TBoldEvent OriginalEvent, const System::TVarRec * Args)
{
  Boolean result = true;
  if (OriginalEvent == bqMayInsert)
    result = (ValidatePartOfSelf(aThing, ( (TThing*)(((TBoldObjectLocator*)(Args[1].VObject))->EnsuredBoldObject)) )
              && (ValidateMaxParts(aThing)) ) ;
  // Can we replace an element in parts with this object?
  else if (OriginalEvent == bqMayReplace)
    result = ValidatePartOfSelf(aThing, (TThing*)(((TBoldObjectLocator*)(Args[1].VObject))->EnsuredBoldObject) );
  return result;
}

Boolean __fastcall TThing::GrantQueryPartOf(TThing* aThing, const System::TVarRec * Args)
{
  // Can we set 'partof' to the object? (i.e. can we insert ourself into 'parts' of the object?)
  Boolean result = ( ValidatePartOfSelf( ((TThing*)(((TBoldObjectLocator*)(Args[1].VObject))->EnsuredBoldObject)), this)
            && ValidateMaxParts( ((TThing*)(((TBoldObjectLocator*)(Args[0].VObject))->EnsuredBoldObject)) ) );
  return result;
}
